#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_query : require
#extension GL_EXT_nonuniform_qualifier : require

#include "common_generated.h"
layout (constant_id = 1) const int KSPEC_MAT_TYPE_GLTF = 1;
layout (constant_id = 10) const int KSPEC_BLEND_STACK_SIZE = 10;
layout (constant_id = 11) const int KSPEC_BUMP_MAPPING = 11;
layout (constant_id = 12) const int KSPEC_MAT_TYPE_DIELECTRIC = 12;
layout (constant_id = 13) const int KSPEC_MAT_FOUR_TEXTURES = 13;
layout (constant_id = 14) const int KSPEC_LIGHT_IES = 14;
layout (constant_id = 15) const int KSPEC_LIGHT_ENV = 15;
layout (constant_id = 16) const int KSPEC_MOTION_BLUR = 16;
layout (constant_id = 17) const int KSPEC_OPTIC_SIM = 17;
layout (constant_id = 18) const int KSPEC_LIGHT_PROJECTIVE = 18;
layout (constant_id = 2) const int KSPEC_MAT_TYPE_GLASS = 2;
layout (constant_id = 3) const int KSPEC_MAT_TYPE_CONDUCTOR = 3;
layout (constant_id = 4) const int KSPEC_MAT_TYPE_DIFFUSE = 4;
layout (constant_id = 5) const int KSPEC_MAT_TYPE_PLASTIC = 5;
layout (constant_id = 6) const int KSPEC_FILMS_STACK_SIZE = 6;
layout (constant_id = 7) const int KSPEC_MAT_TYPE_THIN_FILM = 7;
layout (constant_id = 8) const int KSPEC_SPECTRAL_RENDERING = 8;
layout (constant_id = 9) const int KSPEC_MAT_TYPE_BLEND = 9;

layout(binding = 0, set = 0) buffer data0 { float out_color[]; }; //
layout(binding = 1, set = 0) buffer data1 { RandomGenT m_randomGens[]; }; //
layout(binding = 2, set = 0) buffer data2 { uvec2 m_spec_tex_offset_sz[]; }; //
layout(binding = 3, set = 0) uniform accelerationStructureEXT m_pAccelStruct;
layout(binding = 4, set = 0) buffer data4 { uint m_packedXY[]; }; //
layout(binding = 5, set = 0) buffer data5 { LightSource m_lights[]; }; //
layout(binding = 6, set = 0) buffer data6 { float m_cie_x[]; }; //
layout(binding = 7, set = 0) buffer data7 { float m_precomp_coat_transmittance[]; }; //
layout(binding = 8, set = 0) buffer data8 { int m_allRemapLists[]; }; //
layout(binding = 9, set = 0) buffer data9 { float m_precomp_thin_films[]; }; //
layout(binding = 10, set = 0) buffer data10 { float m_cie_y[]; }; //
layout(binding = 11, set = 0) buffer data11 { uvec2 m_spec_tex_ids_wavelengths[]; }; //
layout(binding = 12, set = 0) uniform sampler2D m_textures[]; //
layout(binding = 13, set = 0) buffer data13 { mat4 m_normMatrices[]; }; //
layout(binding = 14, set = 0) buffer data14 { float m_spec_values[]; }; //
layout(binding = 15, set = 0) buffer data15 { int m_allRemapListsOffsets[]; }; //
layout(binding = 16, set = 0) buffer data16 { LensElementInterface lines[]; }; //
layout(binding = 17, set = 0) buffer data17 { uint m_vertOffset[]; }; //
layout(binding = 18, set = 0) buffer data18 { uint m_films_spec_id_vec[]; }; //
layout(binding = 19, set = 0) buffer data19 { float m_pdfLightData[]; }; //
layout(binding = 20, set = 0) buffer data20 { uint m_triIndices[]; }; //
layout(binding = 21, set = 0) buffer data21 { uvec2 m_spec_offset_sz[]; }; //
layout(binding = 22, set = 0) buffer data22 { mat4 m_normMatrices2[]; }; //
layout(binding = 23, set = 0) buffer data23 { float m_films_eta_k_vec[]; }; //
layout(binding = 24, set = 0) buffer data24 { Material m_materials[]; }; //
layout(binding = 25, set = 0) buffer data25 { float m_films_thickness_vec[]; }; //
layout(binding = 26, set = 0) buffer data26 { float m_cie_z[]; }; //
layout(binding = 27, set = 0) buffer data27 { uint m_instIdToLightInstId[]; }; //
layout(binding = 28, set = 0) buffer data28 { uint m_matIdByPrimId[]; }; //
layout(binding = 29, set = 0) buffer data29 { int m_remapInst[]; }; //
layout(binding = 30, set = 0) buffer data30 { vec4 m_vNorm4f[]; }; //
layout(binding = 31, set = 0) buffer data31 { vec4 m_vTang4f[]; }; //
layout(binding = 32, set = 0) buffer data32 { uint m_matIdOffsets[]; }; //
layout(binding = 33, set = 0) buffer dataUBO { Integrator_Generated_UBO_Data ubo; };

complex a_ior[64];

void dielectricSmoothSampleAndEval_m_materials(uint a_materialsOffset, const vec4 etaSpec, const float _extIOR, vec4 rands, vec3 v, vec3 n, vec2 tc, inout BsdfSample pRes) {
  const float extIOR = m_materials[0 + a_materialsOffset].data[DIELECTRIC_ETA_EXT];

  // if we hit the reverse side of the polygon, reverse the normal back (it was reversed in the RayTrace func.)
  // for correct computations in FrDielectricDetailed
  if ((pRes.flags & RAY_FLAG_HAS_INV_NORMAL) != 0) 
  {
    n = -1 * n;
  }

  vec3 s, t = n;
  CoordinateSystemV2(n, s, t);
  vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));

  float eta = etaSpec.x / extIOR; // take IOR from the first wavelength


  vec4 fr = FrDielectricDetailedV2(wi.z, eta); 

  const float R = fr.x;
  const float cos_theta_t = fr.y;
  const float eta_it = fr.z;
  const float eta_ti = fr.w;  
  const float T = 1 - R;

  if(rands.x < R) // perfect specular reflection
  {
    vec3 wo = vec3(-wi.x,-wi.y,wi.z);
    pRes.val = vec4(R);
    pRes.pdf = R;
    pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
    pRes.flags |= RAY_EVENT_S;
    pRes.ior = _extIOR;
  }
  else // perfect specular transmission
  {
    vec3 wo = refract(wi, cos_theta_t, eta_ti);
    pRes.val = vec4((eta_ti * eta_ti) * T);
    pRes.pdf = T;
    pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
    pRes.flags |= (RAY_EVENT_S | RAY_EVENT_T);
    pRes.ior = (_extIOR == etaSpec.x) ? extIOR : etaSpec.x;
  }

  pRes.val /= max(abs(dot(pRes.dir, n)), 1e-6f);
}

void conductorRoughSampleAndEval_m_materials(uint a_materialsOffset, const vec4 etaSpec, const vec4 kSpec, vec4 rands, vec3 v, vec3 n, vec2 tc, vec3 alpha_tex, inout BsdfSample pRes) {
  if(v.z == 0)
    return;

  const vec4 rgb_reflectance = m_materials[0 + a_materialsOffset].colors[CONDUCTOR_COLOR];

  const vec2 alpha = vec2(min(m_materials[0 + a_materialsOffset].data[CONDUCTOR_ROUGH_U], alpha_tex.x),min(m_materials[0 + a_materialsOffset].data[CONDUCTOR_ROUGH_V], alpha_tex.y));

  vec3 nx,  ny, nz = n;
  CoordinateSystemV2(nz, nx, ny);
  const vec3 wo = vec3(dot(v, nx),dot(v, ny),dot(v, nz));
  if(wo.z == 0)
    return;

  if(wo.z == 0)
    return;

  vec3 wm = trSample(wo, vec2(rands.x,rands.y), alpha);
  vec3 wi = reflect((-1.0f) * wo, wm);

  if(wo.z * wi.z < 0) // not in the same hemisphere
  {
    return;
  }

  vec4 val;
  for(uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
  {
    val[int(i)] = conductorRoughEvalInternal(wo, wi, wm, alpha, make_complex(etaSpec[int(i)],kSpec[int(i)]));
  }

  pRes.val   = val * rgb_reflectance; 
  pRes.dir   = normalize(wi.x * nx + wi.y * ny + wi.z * nz);
  pRes.pdf   = trPDF(wo, wm, alpha) / (4.0f * abs(dot(wo, wm)));
  pRes.flags = RAY_FLAG_HAS_NON_SPEC;
}

void conductorSmoothSampleAndEval_m_materials(uint a_materialsOffset, const vec4 etaSpec, const vec4 kSpec, vec4 rands, vec3 v, vec3 n, vec2 tc, inout BsdfSample pRes) {
  const vec4 rgb_reflectance = m_materials[0 + a_materialsOffset].colors[CONDUCTOR_COLOR];
  const vec3 pefReflDir = reflect((-1.0f)*v, n);
  const float cosThetaOut = dot(pefReflDir, n);
  vec3 dir = pefReflDir;
  float  pdf              = 1.0f;
  
  vec4 val;
  for(uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
  {
    val[int(i)] = FrComplexConductor(cosThetaOut, make_complex(etaSpec[int(i)],kSpec[int(i)]));
    val[int(i)] = (cosThetaOut <= 1e-6f) ? 0.0f : (val[int(i)] / max(cosThetaOut, 1e-6f));  
  }
  
  pRes.val = val * rgb_reflectance; 
  pRes.dir = dir;
  pRes.pdf = pdf;
  pRes.flags = RAY_EVENT_S;
}

void glassSampleAndEval_m_materials(uint a_materialsOffset, const vec4 a_rands, const vec3 a_viewDir, const vec3 a_normal, const vec2 a_tc, inout BsdfSample a_pRes, inout MisData a_misPrev) {
  // PLEASE! use 'a_materials[0].' for a while ... , not a_materials-> and not *(a_materials).
  const vec4 colorReflect = m_materials[0 + a_materialsOffset].colors[GLASS_COLOR_REFLECT];   
  const vec4 colorTransp = m_materials[0 + a_materialsOffset].colors[GLASS_COLOR_TRANSP];
  const float  ior                  = m_materials[0 + a_materialsOffset].data[GLASS_FLOAT_IOR];

  const vec3 rayDir = (-1.0f) * a_viewDir;
  float relativeIor   = ior / a_misPrev.ior;

  if ((a_pRes.flags & RAY_FLAG_HAS_INV_NORMAL) != 0) // hit the reverse side of the polygon from the volume
  {
    if (a_misPrev.ior == ior) // in the previous hit there was material with a equal IOR
      relativeIor = 1.0f / ior;
  }

  const float fresnel = fresnel2(a_viewDir, a_normal, relativeIor);

  vec3 dir;

  if (a_rands.w < fresnel) // reflection
  {
    dir            = reflect2(rayDir, a_normal);
    a_pRes.val    =  colorReflect;
    a_pRes.flags |= RAY_EVENT_S;
  }
  else
  {
    dir            = refract2(rayDir, a_normal, relativeIor);
    a_pRes.val    = colorTransp;
    a_misPrev.ior = ior;
    a_pRes.flags |= (RAY_EVENT_S | RAY_EVENT_T);
  }

  const float cosThetaOut = abs(dot(dir, a_normal));
  
  a_pRes.val      /= max(cosThetaOut, 1e-6f);// BSDF is multiplied (outside) by cosThetaOut. For mirrors this shouldn't be done, so we pre-divide here instead.
  a_pRes.dir       = dir;
  a_pRes.pdf       = 1.0f;
}

void diffuseSampleAndEval_m_materials(uint a_materialsOffset, vec4 a_reflSpec, vec4 rands, vec3 v, vec3 n, vec2 tc, inout BsdfSample pRes) {
  const uint   cflags     = m_materials[0 + a_materialsOffset].cflags;
  const vec3 lambertDir = lambertSample(vec2(rands.x,rands.y), v, n);
  const float  lambertPdf = lambertEvalPDF(lambertDir, v, n);
  const float  lambertVal = lambertEvalBSDF(lambertDir, v, n);

  pRes.dir   = lambertDir;
  pRes.val   = lambertVal * a_reflSpec;
  pRes.pdf   = lambertPdf;
  pRes.flags = RAY_FLAG_HAS_NON_SPEC;
        
  if ((cflags & GLTF_COMPONENT_ORENNAYAR) != 0)
    pRes.val *= orennayarFunc(lambertDir, (-1.0f) * v, n, m_materials[0 + a_materialsOffset].data[DIFFUSE_ROUGHNESS]);
            
}

void plasticEval_m_materials_m_precomp_coat_transmittance(uint a_materialsOffset, vec4 a_reflSpec, vec3 l, vec3 v, vec3 n, vec2 tc, inout BsdfEval pRes, uint transmittanceOffset) {
  const float alpha     = m_materials[0 + a_materialsOffset].data[PLASTIC_ROUGHNESS];
  const float eta       = m_materials[0 + a_materialsOffset].data[PLASTIC_IOR_RATIO];
  const float spec_weight = m_materials[0 + a_materialsOffset].data[PLASTIC_SPEC_SAMPLE_WEIGHT];
  const uint  nonlinear   = m_materials[0 + a_materialsOffset].nonlinear;
  const float internal_refl = m_materials[0 + a_materialsOffset].data[PLASTIC_PRECOMP_REFLECTANCE];

  const vec2 alpha2 = vec2(alpha,alpha);
  
  vec3 s = n;
  vec3 t = n;
  CoordinateSystemV2(n, s, t);
  
  const vec3 wo = vec3(dot(l, s),dot(l, t),dot(l, n));
  const vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));
  if(wi.z * wo.z <= 0)
  {
    return;
  }
  const float cos_theta_i = max(wi.z, EPSILON_32);
  const float cos_theta_o = max(wo.z, EPSILON_32);

  // float t_i = lerp_gather(transmittance, cos_theta_i, MI_ROUGH_TRANSMITTANCE_RES);
  float t_i = 0.0f;
  {
    float x = cos_theta_i;
    x *= float(MI_ROUGH_TRANSMITTANCE_RES - 1);
    uint index = min(uint32_t(x), uint32_t(MI_ROUGH_TRANSMITTANCE_RES - 2));

    float v0 = m_precomp_coat_transmittance[index + transmittanceOffset];
    float v1 = m_precomp_coat_transmittance[index + 1 + transmittanceOffset];

    t_i = mix(v0, v1, x - float(index));
  }

  float prob_specular = (1.f - t_i) * spec_weight;
  float prob_diffuse  = t_i * (1.f - spec_weight);

  if(prob_diffuse != 0.0f && prob_specular != 0.0f)
  {
    prob_specular = prob_specular / (prob_specular + prob_diffuse);
    prob_diffuse  = 1.f - prob_specular;
  }
  else
  {
    prob_diffuse  = 1.0f;
    prob_specular = 0.0f;
  }

 
  vec3 H = normalize(wo + wi);
  float  D = eval_microfacet(H, alpha2, 1);
  float smith_g1_wi = smith_g1(wi, H, alpha2);

  float pdf = D * smith_g1_wi / (4.f * cos_theta_i);
  pdf *= prob_specular;
  pdf += prob_diffuse * INV_PI * cos_theta_o;


  const float F = FrDielectric(dot(wi, H), eta); 
  float G = smith_g1(wo, H, alpha2) * smith_g1_wi;
  float val = F * D * G / (4.f * cos_theta_i * cos_theta_o);

  // float t_o = lerp_gather(transmittance, cos_theta_o, MI_ROUGH_TRANSMITTANCE_RES); 
  float t_o = 0.0f;
  {
    float x = cos_theta_o;
    x *= float(MI_ROUGH_TRANSMITTANCE_RES - 1);
    uint index = min(uint32_t(x), uint32_t(MI_ROUGH_TRANSMITTANCE_RES - 2));

    float v0 = m_precomp_coat_transmittance[index + transmittanceOffset];
    float v1 = m_precomp_coat_transmittance[index + 1 + transmittanceOffset];

    t_o = mix(v0, v1, x - float(index));
  }

  vec4 diffuse = a_reflSpec / (1.f - (nonlinear > 0 ? (a_reflSpec * internal_refl) : vec4(internal_refl)));
  const float inv_eta_2 = 1.f / (eta * eta);

  pRes.val   = vec4(val) + diffuse * (INV_PI * inv_eta_2 * /*cos_theta_o **/ t_i * t_o );
  pRes.pdf   = pdf;
}

void diffuseEval_m_materials(uint a_materialsOffset, vec4 a_reflSpec, vec3 l, vec3 v, vec3 n, vec2 tc, inout BsdfEval res) {
  const uint cflags = m_materials[0 + a_materialsOffset].cflags;
 
  float lambertVal       = lambertEvalBSDF(l, v, n);
  const float lambertPdf = lambertEvalPDF (l, v, n);

  if ((cflags & GLTF_COMPONENT_ORENNAYAR) != 0)
    lambertVal *= orennayarFunc(l, v, n, m_materials[0 + a_materialsOffset].data[DIFFUSE_ROUGHNESS]);

  res.val = lambertVal * a_reflSpec; 
  res.pdf = lambertPdf; 
}

void gltfSampleAndEval_m_materials(uint a_materialsOffset, vec4 rands, vec3 v, vec3 n, vec2 tc, vec4 baseColor, vec4 fourParams, inout BsdfSample pRes) {
  // PLEASE! use 'a_materials[0].' for a while ... , not a_materials-> and not *(a_materials).
  const uint   cflags     = m_materials[0 + a_materialsOffset].cflags;
  const vec4 metalCol = m_materials[0 + a_materialsOffset].colors[GLTF_COLOR_METAL]*baseColor; 
  const vec4 coatCol = m_materials[0 + a_materialsOffset].colors[GLTF_COLOR_COAT];  
  const float  roughness  = clamp(1.0f - m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_GLOSINESS]*fourParams.x, 0.0f, 1.0f);   
  float        metalness  = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_ALPHA]*fourParams.y;
  const float  coatValue  = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_REFL_COAT]*fourParams.z;                 
  const float  fresnelIOR = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_IOR];
  
  if(cflags == GLTF_COMPONENT_METAL) // assume only GGX-based metal component set
    metalness = 1.0f;

  vec3 ggxDir;
  float  ggxPdf; 
  float  ggxVal;

  if(roughness == 0.0f) // perfect specular reflection in coating or metal layer
  {
    const vec3 pefReflDir = reflect((-1.0f) * v, n);
    const float cosThetaOut = dot(pefReflDir, n);
    ggxDir                  = pefReflDir;
    ggxVal                  = (cosThetaOut <= 1e-6f) ? 0.0f : (1.0f/max(cosThetaOut, 1e-6f));  // BSDF is multiplied (outside) by cosThetaOut. For mirrors this shouldn't be done, so we pre-divide here instead.
    ggxPdf                  = 1.0f;
  }
  else
  {
    ggxDir                  = ggxSample(vec2(rands.x,rands.y), v, n, roughness);
    ggxPdf                  = ggxEvalPDF (ggxDir, v, n, roughness); 
    ggxVal                  = ggxEvalBSDF(ggxDir, v, n, roughness);
  }

  const vec3 lambertDir = lambertSample(vec2(rands.x,rands.y), v, n);
  const float  lambertPdf   = lambertEvalPDF(lambertDir, v, n);
  const float  lambertVal   = lambertEvalBSDF(lambertDir, v, n);

  // (1) select between metal and dielectric via rands.z
  //
  float pdfSelect = 1.0f;
  if(rands.z < metalness) // select metall
  {
    pdfSelect         *= metalness;
    const float  VdotH = dot(v,normalize(v + ggxDir));
    pRes.dir          = ggxDir;
    pRes.val          = ggxVal * metalness * hydraFresnelCond(metalCol, VdotH, fresnelIOR, roughness); //TODO: disable fresnel here for mirrors
    pRes.pdf          = ggxPdf;
    pRes.flags        = (roughness == 0.0f) ? RAY_EVENT_S : RAY_FLAG_HAS_NON_SPEC;
  }
  else                // select dielectric
  {
    pdfSelect *= 1.0f - metalness;
    
    // (2) now select between specular and diffise via rands.w
    //
    const float f_i           = FrDielectricPBRT(abs(dot(v,n)), 1.0f, fresnelIOR); 
    const float prob_specular = 0.5f*coatValue;
    const float prob_diffuse  = 1.0f-prob_specular;
    
    if(rands.w < prob_specular) // specular
    {
      pdfSelect      *= prob_specular;
      pRes.dir       = ggxDir;
      pRes.val       = ggxVal*coatCol*(1.0f - metalness)*f_i*coatValue;
      pRes.pdf       = ggxPdf;
      pRes.flags     = (roughness == 0.0f) ? RAY_EVENT_S : RAY_FLAG_HAS_NON_SPEC;
    } 
    else
    {
      pdfSelect      *= prob_diffuse; // lambert
      pRes.dir       = lambertDir;
      pRes.val       = lambertVal * baseColor * (1.0f - metalness);
      pRes.pdf       = lambertPdf;
      pRes.flags     = RAY_FLAG_HAS_NON_SPEC;
            
      if(coatValue > 0.0f && fresnelIOR > 0.0f) // Plastic, account for retroreflection between surface and coating layer
      {
        const float m_fdr_int = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_MI_FDR_INT];
        const float f_o       = FrDielectricPBRT(abs(dot(lambertDir, n)), 1.0f, fresnelIOR);
        pRes.val            *= mix(1.0f, (1.0f - f_i) * (1.0f - f_o) / (fresnelIOR * fresnelIOR * (1.0f - m_fdr_int)), coatValue);
      }
    }
  }   
  pRes.pdf *= pdfSelect;
}

void filmRoughEval_m_materials_m_films_thickness_vec_m_precomp_thin_films(uint a_materialsOffset, uint thicknessOffset, uint layers, const vec4 a_wavelengths, vec3 l, vec3 v, vec3 n, vec2 tc, vec3 alpha_tex, inout BsdfEval pRes, uint precomputedOffset) {
  if (a_ior[layers].im < 0.001)
  {
    return;
  }

  const float extIOR = m_materials[0 + a_materialsOffset].data[FILM_ETA_EXT];
  uint32_t refl_offset;
  uint32_t refr_offset;

  bool reversed = false;
  if (dot(v, n) < 0.f && a_ior[layers].im < 0.001)
  {
    reversed = true;
    refl_offset = FILM_ANGLE_RES * FILM_LENGTH_RES * 2;
    refr_offset = FILM_ANGLE_RES * FILM_LENGTH_RES * 3;
  }
  else
  {
    refl_offset = 0;
    refr_offset = FILM_ANGLE_RES * FILM_LENGTH_RES;
  }

  const vec2 alpha = vec2(min(m_materials[0 + a_materialsOffset].data[FILM_ROUGH_V], alpha_tex.x),min(m_materials[0 + a_materialsOffset].data[FILM_ROUGH_U], alpha_tex.y));

  vec3 s, t = n;
  CoordinateSystemV2(n, s, t);
  const vec3 wo = vec3(dot(l, s),dot(l, t),dot(l, n));
  const vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));
  const vec3 wm = normalize(wo + wi);

  if (wi.z * wo.z < 0.f)
  {
    return;
  }

  float ior = a_ior[layers].re / extIOR;
  if (reversed)
  {
    ior = 1.f / ior;
  }

  float cosThetaI = clamp(abs(dot(wo, wm)), 0.00001, 1.0f);
  
  float R = 0.f;
  uint precompFlag = floatBitsToUint(m_materials[0 + a_materialsOffset].data[FILM_PRECOMP_FLAG]);
  if (precompFlag == 0u)
  {
    if (layers == 2)
    {
      if (!reversed)
      {
        //R = FrFilmRefl(cosThetaI, a_ior[0], a_ior[1], a_ior[2], 50.f + (n.y + 1.f) * 100.f, a_wavelengths[0]);
        R = FrFilmRefl(cosThetaI, a_ior[0], a_ior[1], a_ior[2], m_films_thickness_vec[0 + thicknessOffset], a_wavelengths[0]);
      }
      else
      {
        R = FrFilmRefl(cosThetaI, a_ior[2], a_ior[1], a_ior[0], m_films_thickness_vec[0 + thicknessOffset], a_wavelengths[0]); 
      }
    }
    else if (layers > 2)
    {
      if (!reversed)
      { 
        //result = multFrFilm(cosThetaI, a_ior, thickness, layers, a_wavelengths[0]);
        complex a_cosTheta[KSPEC_FILMS_STACK_SIZE + 1];
        complex a_phaseDiff[KSPEC_FILMS_STACK_SIZE - 1];
        a_cosTheta[0] = to_complex(cosThetaI);

        float sinThetaI = 1.0f - cosThetaI * cosThetaI;
        complex sinTheta;
        complex cosTheta;
        for (uint i = 1; i <= layers; ++i)
        {
          sinTheta = real_div_complex(sinThetaI * a_ior[0].re * a_ior[0].re,(complex_mul(make_complex(a_ior[i].re,a_ior[i].im),a_ior[i])));
          cosTheta = complex_sqrt(real_sub_complex(1.0f,sinTheta));
          a_cosTheta[i] = cosTheta;
          if (i < layers)
            a_phaseDiff[i - 1] = filmPhaseDiff(cosTheta, a_ior[i], m_films_thickness_vec[i - 1 + thicknessOffset], a_wavelengths[0]);
        }
        uint polarization[2] = {PolarizationS, PolarizationP};
        for (uint p = 0; p < 2; ++p)
        {
          complex FrRefl = FrComplexRefl(a_cosTheta[layers - 1], a_cosTheta[layers], a_ior[layers - 1], a_ior[layers], p);
          for (uint i = layers - 1; i > 0; --i)
          {
            complex FrReflI = FrComplexRefl(a_cosTheta[i - 1], a_cosTheta[i], a_ior[i - 1], a_ior[i], p);
            FrRefl = complex_mul(complex_mul(FrRefl,to_complex(exp(-a_phaseDiff[i - 1].im))),make_complex(cos(a_phaseDiff[i - 1].re),sin(a_phaseDiff[i - 1].re)));
            complex denom = real_div_complex(1.f,(real_add_complex(1,complex_mul(FrReflI,FrRefl))));
            FrRefl = complex_mul((complex_add(FrReflI,FrRefl)),denom);
          }
          R += complex_norm(FrRefl) / 2;
        }
      }
      else
      {
        //result = multFrFilm_r(cosThetaI, a_ior, thickness, layers, a_wavelengths[0]);
        complex a_cosTheta[KSPEC_FILMS_STACK_SIZE + 1];
        complex a_phaseDiff[KSPEC_FILMS_STACK_SIZE - 1];
        a_cosTheta[layers] = to_complex(cosThetaI);

        float sinThetaI = 1.0f - cosThetaI * cosThetaI;
        complex sinTheta = to_complex(1.0);
        complex cosTheta = to_complex(1.0);
        for (uint i = layers; i > 0; --i)
        {
          sinTheta = real_div_complex(sinThetaI * a_ior[layers].re * a_ior[layers].re,(complex_mul(make_complex(a_ior[i - 1].re,a_ior[i - 1].im),a_ior[i - 1])));
          cosTheta = complex_sqrt(real_sub_complex(1.0f,sinTheta));
          a_cosTheta[i - 1] = cosTheta;
          if (i > 1)
            a_phaseDiff[i - 2] = filmPhaseDiff(cosTheta, a_ior[i - 1], m_films_thickness_vec[i - 2 + thicknessOffset], a_wavelengths[0]);
        }
        uint polarization[2] = {PolarizationS, PolarizationP};
        for (uint p = 0; p < 2; ++p)
        {
          complex FrRefl = FrComplexRefl(a_cosTheta[1], a_cosTheta[0], a_ior[1], a_ior[0], p);
          for (uint i = 1; i < layers; ++i)
          {
            complex FrReflI = FrComplexRefl(a_cosTheta[i + 1], a_cosTheta[i], a_ior[i + 1], a_ior[i], p);
            FrRefl = complex_mul(complex_mul(FrRefl,to_complex(exp(-a_phaseDiff[i - 1].im))),make_complex(cos(a_phaseDiff[i - 1].re),sin(a_phaseDiff[i - 1].re)));
            complex denom = real_div_complex(1.f,(real_add_complex(1,complex_mul(FrReflI,FrRefl))));
            FrRefl = complex_mul((complex_add(FrReflI,FrRefl)),denom);
          }
          R += complex_norm(FrRefl) / 2;
        }
      }
    } 
  }
  else
  {
    float w = clamp((a_wavelengths[0] - LAMBDA_MIN) / (LAMBDA_MAX - LAMBDA_MIN), 0.f, 1.f);
    float theta = clamp(acos(cosThetaI) * 2.f / M_PI, 0.f, 1.f);
    //result.refl = lerp_gather_2d(reflectance, w, theta, FILM_LENGTH_RES, FILM_ANGLE_RES);
    //result.refr = lerp_gather_2d(transmittance, w, theta, FILM_LENGTH_RES, FILM_ANGLE_RES);
    w *= FILM_LENGTH_RES - 1;
    theta *= FILM_ANGLE_RES - 1;
    uint index1 = min(uint32_t(w), uint32_t(FILM_LENGTH_RES - 2));
    uint index2 = min(uint32_t(theta), uint32_t(FILM_ANGLE_RES - 2));

    float alpha = w - float(index1);
    float beta = theta - float(index2);

    float v0 = mix(m_precomp_thin_films[refl_offset + index1 * FILM_ANGLE_RES + index2 + precomputedOffset], m_precomp_thin_films[refl_offset + (index1 + 1) * FILM_ANGLE_RES + index2 + precomputedOffset], alpha);
    float v1 = mix(m_precomp_thin_films[refl_offset + index1 * FILM_ANGLE_RES + index2 + 1 + precomputedOffset], m_precomp_thin_films[refl_offset + (index1 + 1) * FILM_ANGLE_RES + index2 + 1 + precomputedOffset], alpha);
    R = mix(v0, v1, beta);
  }

  const float cos_theta_i = max(wi.z, EPSILON_32);
  const float cos_theta_o = max(wo.z, EPSILON_32);

  float D = eval_microfacet(wm, alpha, 1);
  float G = microfacet_G(wi, wo, wm, alpha);
  pRes.val = D * G * vec4(R) / (4.0f * cos_theta_i * cos_theta_o);
  pRes.pdf = D * smith_g1(wi, wm, alpha) / (4.0f * cos_theta_i);
}

vec4 SampleUniformSpectrum_m_spec_values(uint a_spec_valuesOffset, vec4 a_wavelengths, uint a_sz) {
  const int  WAVESN = int(LAMBDA_MAX-LAMBDA_MIN);
  const ivec4 index1 = ivec4(min(max(a_wavelengths - vec4(LAMBDA_MIN), vec4(0.0f)), vec4(WAVESN - 1)));   
  const ivec4 index2 = min(index1 + ivec4(1), ivec4(WAVESN-1));

  // const float4 mask = {index1.x >= WAVESN ? 0 : 1, index1.y >= WAVESN ? 0 : 1, index1.z >= WAVESN ? 0 : 1, index1.w >= WAVESN ? 0 : 1};
  

  const vec4 x1 = vec4(LAMBDA_MIN) + vec4(index1);
  const vec4 y1 = vec4(m_spec_values[index1[0] + a_spec_valuesOffset],m_spec_values[index1[1] + a_spec_valuesOffset],m_spec_values[index1[2] + a_spec_valuesOffset],m_spec_values[index1[3] + a_spec_valuesOffset]); // TODO: reorder mem access for better cache: (index1[0], index2[0])
  const vec4 y2 = vec4(m_spec_values[index2[0] + a_spec_valuesOffset],m_spec_values[index2[1] + a_spec_valuesOffset],m_spec_values[index2[2] + a_spec_valuesOffset],m_spec_values[index2[3] + a_spec_valuesOffset]); // TODO: reorder mem access for better cache: (index1[1], index2[1])

  vec4 res = (y1 + (a_wavelengths - x1) * (y2 - y1));
  // if(std::isinf(res.x) || std::isnan(res.x) || res.x < 0)
  // {
  //   int a = 2;
  // }

  return res;
}

uint BinarySearchU2_m_spec_tex_ids_wavelengths(uint arrayOffset, uint array_sz, float val) {
  int last = int(array_sz) - 2, first = 1;
  while (last > 0) 
  {
    uint half = uint(last) >> 1, middle = uint(first) + half;
    bool predResult = float(m_spec_tex_ids_wavelengths[middle + arrayOffset].y) <= val;
    first = predResult ? int(middle + 1) : first;
    last = predResult ? last - int(half + 1) : int(half);
  }
  return uint(clamp(int(first - 1), 0, int(array_sz - 2)));
}

void plasticSampleAndEval_m_materials_m_precomp_coat_transmittance(uint a_materialsOffset, vec4 a_reflSpec, vec4 rands, vec3 v, vec3 n, vec2 tc, inout BsdfSample pRes, uint transmittanceOffset) {
  const float alpha         = m_materials[0 + a_materialsOffset].data[PLASTIC_ROUGHNESS];
  const float eta           = m_materials[0 + a_materialsOffset].data[PLASTIC_IOR_RATIO];
  const float spec_weight   = m_materials[0 + a_materialsOffset].data[PLASTIC_SPEC_SAMPLE_WEIGHT];
  const uint  nonlinear     = m_materials[0 + a_materialsOffset].nonlinear;
  const float internal_refl = m_materials[0 + a_materialsOffset].data[PLASTIC_PRECOMP_REFLECTANCE];
  const vec2 alpha2 = vec2(alpha,alpha);

  vec3 s = n;
  vec3 t = n;
  CoordinateSystemV2(n, s, t);
  
  const vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));
  if(wi.z <= 0)
    return;

  const float cos_theta_i = max(wi.z, EPSILON_32);

  // float t_i = lerp_gather(transmittance, cos_theta_i, MI_ROUGH_TRANSMITTANCE_RES);
  float t_i = 0.0f;
  {
    float x = cos_theta_i;
    x *= float(MI_ROUGH_TRANSMITTANCE_RES - 1);
    uint index = min(uint32_t(x), uint32_t(MI_ROUGH_TRANSMITTANCE_RES - 2));

    float v0 = m_precomp_coat_transmittance[index + transmittanceOffset];
    float v1 = m_precomp_coat_transmittance[index + 1 + transmittanceOffset];

    t_i = mix(v0, v1, x - float(index));
  }

  float prob_specular = (1.f - t_i) * spec_weight;
  float prob_diffuse  = t_i * (1.f - spec_weight);

  if(prob_diffuse != 0.0f && prob_specular != 0.0f)
  {
    prob_specular = prob_specular / (prob_specular + prob_diffuse);
    prob_diffuse  = 1.f - prob_specular;
  }
  else
  {
    prob_diffuse  = 1.0f;
    prob_specular = 0.0f;
  }

  const bool sample_specular = rands.z < prob_specular;
  const bool sample_diffuse = !sample_specular;

  vec3 wo = vec3(0.0f,0.0f,0.0f);
  if(sample_specular)
  {
    const vec3 wm = (sample_visible_normal(wi, vec2(rands.x,rands.y), alpha2)).xyz;
    wo = reflect((-1.0f) * wi, wm);
  }

  if(sample_diffuse)
  {
    wo = square_to_cosine_hemisphere(vec2(rands.x,rands.y));
  }

  if(cos_theta_i * wo.z <= 0)
  {
    return;
  }

  const float cos_theta_o = max(wo.z, EPSILON_32);

  vec3 H = normalize(wo + wi);
  float  D = eval_microfacet(H, alpha2, 1);

  float pdf = D * smith_g1(wi, H, alpha2) / (4.f * cos_theta_i);
  pdf *= prob_specular;
  pdf += prob_diffuse * INV_PI * cos_theta_o;

  const float F = FrDielectric(dot(wi, H), eta); 
  float G = microfacet_G(wi, wo, H, alpha2);
  float val = F * D * G / (4.f * cos_theta_i * cos_theta_o);

  // float t_o = lerp_gather(transmittance, cos_theta_o, MI_ROUGH_TRANSMITTANCE_RES); 
  float t_o = 0.0f;
  {
    float x = cos_theta_o;
    x *= float(MI_ROUGH_TRANSMITTANCE_RES - 1);
    uint index = min(uint32_t(x), uint32_t(MI_ROUGH_TRANSMITTANCE_RES - 2));

    float v0 = m_precomp_coat_transmittance[index + transmittanceOffset];
    float v1 = m_precomp_coat_transmittance[index + 1 + transmittanceOffset];

    t_o = mix(v0, v1, x - float(index));
  }

  vec4 diffuse = a_reflSpec / (1.f - (nonlinear > 0 ? (a_reflSpec * internal_refl) : vec4(internal_refl)));
  const float inv_eta_2 = 1.f / (eta * eta);

  pRes.dir   = normalize(wo.x * s + wo.y * t + wo.z * n);
  pRes.val   = vec4(val) + diffuse * (INV_PI * inv_eta_2 * /*cos_theta_o **/ t_i * t_o );
  pRes.pdf   = pdf;
  pRes.flags = RAY_FLAG_HAS_NON_SPEC;
}

void filmRoughSampleAndEval_m_materials_m_films_thickness_vec_m_precomp_thin_films(uint a_materialsOffset, uint thicknessOffset, uint layers, const vec4 a_wavelengths, const float _extIOR, vec4 rands, vec3 v, vec3 n, vec2 tc, vec3 alpha_tex, inout BsdfSample pRes, uint precomputedOffset) {
  const float extIOR = m_materials[0 + a_materialsOffset].data[FILM_ETA_EXT];

  bool reversed = false;
  uint32_t refl_offset;
  uint32_t refr_offset;
  if ((pRes.flags & RAY_FLAG_HAS_INV_NORMAL) != 0) // inside of object
  {
    n = -1 * n;
  }

  if (dot(v, n) < 0.f && a_ior[layers].im < 0.001)
  {
    reversed = true;
    refl_offset = FILM_ANGLE_RES * FILM_LENGTH_RES * 2;
    refr_offset = FILM_ANGLE_RES * FILM_LENGTH_RES * 3;
  }
  else
  {
    refl_offset = 0;
    refr_offset = FILM_ANGLE_RES * FILM_LENGTH_RES;
  }

  const vec2 alpha = vec2(min(m_materials[0 + a_materialsOffset].data[FILM_ROUGH_V], alpha_tex.x),min(m_materials[0 + a_materialsOffset].data[FILM_ROUGH_U], alpha_tex.y));

  vec3 s, t = n;
  CoordinateSystemV2(n, s, t);
  vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));

  float ior = a_ior[layers].re / extIOR;
  if (reversed)
  {
    wi = -1 * wi;
    ior = 1.f / ior;
  }

  const vec4 wm_pdf = sample_visible_normal(wi, vec2(rands.x,rands.y), alpha);
  const vec3 wm = wm_pdf.xyz;
  if(wm_pdf.w == 0.0f) // not in the same hemisphere
  {
    return;
  }

  float cosThetaI = clamp(abs(dot(wi, wm)), 0.00001, 1.0f);
  
  float R, T;
  FrReflRefr result = {0.f, 0.f};

  uint precompFlag = floatBitsToUint(m_materials[0 + a_materialsOffset].data[FILM_PRECOMP_FLAG]);

  if (precompFlag == 0u)
  {
    if (layers == 2)
    {
      if (!reversed)
      {
        //result = FrFilm(cosThetaI, a_ior[0], a_ior[1], a_ior[2], 50.f + (n.y + 1.f) * 100.f, a_wavelengths[0]);
        result = FrFilm(cosThetaI, a_ior[0], a_ior[1], a_ior[2], m_films_thickness_vec[0 + thicknessOffset], a_wavelengths[0]);
      }
      else
      {
        result = FrFilm(cosThetaI, a_ior[2], a_ior[1], a_ior[0], m_films_thickness_vec[0 + thicknessOffset], a_wavelengths[0]);
      }
    }
    else if (layers > 2)
    {
       if (!reversed)
      { 
        //result = multFrFilm(cosThetaI, a_ior, thickness, layers, a_wavelengths[0]);
        complex a_cosTheta[KSPEC_FILMS_STACK_SIZE + 1];
        complex a_phaseDiff[KSPEC_FILMS_STACK_SIZE - 1];
        a_cosTheta[0] = to_complex(cosThetaI);

        float sinThetaI = 1.0f - cosThetaI * cosThetaI;
        complex sinTheta;
        complex cosTheta;
        for (uint i = 1; i <= layers; ++i)
        {
          sinTheta = real_div_complex(sinThetaI * a_ior[0].re * a_ior[0].re,(complex_mul(make_complex(a_ior[i].re,a_ior[i].im),a_ior[i])));
          cosTheta = complex_sqrt(real_sub_complex(1.0f,sinTheta));
          a_cosTheta[i] = cosTheta;
          if (i < layers)
            a_phaseDiff[i - 1] = filmPhaseDiff(cosTheta, a_ior[i], m_films_thickness_vec[i - 1 + thicknessOffset], a_wavelengths[0]);
        }
        uint polarization[2] = {PolarizationS, PolarizationP};
        for (uint p = 0; p < 2; ++p)
        {
          complex FrRefl = FrComplexRefl(a_cosTheta[layers - 1], a_cosTheta[layers], a_ior[layers - 1], a_ior[layers], p);
          complex FrRefr = FrComplexRefr(a_cosTheta[layers - 1], a_cosTheta[layers], a_ior[layers - 1], a_ior[layers], p);
          for (uint i = layers - 1; i > 0; --i)
          {
            complex FrReflI = FrComplexRefl(a_cosTheta[i - 1], a_cosTheta[i], a_ior[i - 1], a_ior[i], p);
            complex FrRefrI = FrComplexRefr(a_cosTheta[i - 1], a_cosTheta[i], a_ior[i - 1], a_ior[i], p);
            complex temp_exp = real_mul_complex(exp(-a_phaseDiff[i - 1].im / 2.f),make_complex(cos(a_phaseDiff[i - 1].re / 2.f),sin(a_phaseDiff[i - 1].re / 2.f)));
            FrRefr = complex_mul(complex_mul(FrRefrI,FrRefr),temp_exp);
            FrRefl = complex_mul(complex_mul(FrRefl,temp_exp),temp_exp);
            complex denom = real_div_complex(1.f,(real_add_complex(1,complex_mul(FrReflI,FrRefl))));
            FrRefr = complex_mul(FrRefr,denom);
            FrRefl = complex_mul((complex_add(FrReflI,FrRefl)),denom);
          }
          result.refl += complex_norm(FrRefl) / 2;
          result.refr += complex_norm(FrRefr) / 2;
        }
        result.refr *= getRefractionFactor(cosThetaI, a_cosTheta[layers], a_ior[0], a_ior[layers]);
      }
      else
      {
        //result = multFrFilm_r(cosThetaI, a_ior, thickness, layers, a_wavelengths[0]);
        complex a_cosTheta[KSPEC_FILMS_STACK_SIZE + 1];
        complex a_phaseDiff[KSPEC_FILMS_STACK_SIZE - 1];
        a_cosTheta[layers] = to_complex(cosThetaI);

        float sinThetaI = 1.0f - cosThetaI * cosThetaI;
        complex sinTheta = to_complex(1.0);
        complex cosTheta = to_complex(1.0);
        for (uint i = layers; i > 0; --i)
        {
          sinTheta = real_div_complex(sinThetaI * a_ior[layers].re * a_ior[layers].re,(complex_mul(make_complex(a_ior[i - 1].re,a_ior[i - 1].im),a_ior[i - 1])));
          cosTheta = complex_sqrt(real_sub_complex(1.0f,sinTheta));
          a_cosTheta[i - 1] = cosTheta;
          if (i > 1)
            a_phaseDiff[i - 2] = filmPhaseDiff(cosTheta, a_ior[i - 1], m_films_thickness_vec[i - 2 + thicknessOffset], a_wavelengths[0]);
        }
        uint polarization[2] = {PolarizationS, PolarizationP};
        for (uint p = 0; p < 2; ++p)
        {
          complex FrRefl = FrComplexRefl(a_cosTheta[1], a_cosTheta[0], a_ior[1], a_ior[0], p);
          complex FrRefr = FrComplexRefr(a_cosTheta[1], a_cosTheta[0], a_ior[1], a_ior[0], p);
          for (uint i = 1; i < layers; ++i)
          {
            complex FrReflI = FrComplexRefl(a_cosTheta[i + 1], a_cosTheta[i], a_ior[i + 1], a_ior[i], p);
            complex FrRefrI = FrComplexRefr(a_cosTheta[i + 1], a_cosTheta[i], a_ior[i + 1], a_ior[i], p);
            complex temp_exp = real_mul_complex(exp(-a_phaseDiff[i - 1].im / 2.f),make_complex(cos(a_phaseDiff[i - 1].re / 2.f),sin(a_phaseDiff[i - 1].re / 2.f)));
            FrRefr = complex_mul(complex_mul(FrRefrI,FrRefr),temp_exp);
            FrRefl = complex_mul(complex_mul(FrRefl,temp_exp),temp_exp);
            complex denom = real_div_complex(1.f,(real_add_complex(1,complex_mul(FrReflI,FrRefl))));
            FrRefr = complex_mul(FrRefr,denom);
            FrRefl = complex_mul((complex_add(FrReflI,FrRefl)),denom);
          }
          result.refl += complex_norm(FrRefl) / 2;
          result.refr += complex_norm(FrRefr) / 2;
        }
        result.refr *= getRefractionFactor(cosThetaI, a_cosTheta[layers], a_ior[layers], a_ior[0]);
      }
    } 
  }
  else
  {
    float w = clamp((a_wavelengths[0] - LAMBDA_MIN) / (LAMBDA_MAX - LAMBDA_MIN), 0.f, 1.f);
    float theta = clamp(acos(cosThetaI) * 2.f / M_PI, 0.f, 1.f);
    //result.refl = lerp_gather_2d(reflectance, w, theta, FILM_LENGTH_RES, FILM_ANGLE_RES);
    //result.refr = lerp_gather_2d(transmittance, w, theta, FILM_LENGTH_RES, FILM_ANGLE_RES);
    w *= FILM_LENGTH_RES - 1;
    theta *= FILM_ANGLE_RES - 1;
    uint index1 = min(uint32_t(w), uint32_t(FILM_LENGTH_RES - 2));
    uint index2 = min(uint32_t(theta), uint32_t(FILM_ANGLE_RES - 2));

    float alpha = w - float(index1);
    float beta = theta - float(index2);

    float v0 = mix(m_precomp_thin_films[refl_offset + index1 * FILM_ANGLE_RES + index2 + precomputedOffset], m_precomp_thin_films[refl_offset + (index1 + 1) * FILM_ANGLE_RES + index2 + precomputedOffset], alpha);
    float v1 = mix(m_precomp_thin_films[refl_offset + index1 * FILM_ANGLE_RES + index2 + 1 + precomputedOffset], m_precomp_thin_films[refl_offset + (index1 + 1) * FILM_ANGLE_RES + index2 + 1 + precomputedOffset], alpha);
    result.refl = mix(v0, v1, beta);

    v0 = mix(m_precomp_thin_films[refr_offset + index1 * FILM_ANGLE_RES + index2 + precomputedOffset], m_precomp_thin_films[refr_offset + (index1 + 1) * FILM_ANGLE_RES + index2 + precomputedOffset], alpha);
    v1 = mix(m_precomp_thin_films[refr_offset + index1 * FILM_ANGLE_RES + index2 + 1 + precomputedOffset], m_precomp_thin_films[refr_offset + (index1 + 1) * FILM_ANGLE_RES + index2 + 1 + precomputedOffset], alpha);
    result.refr = mix(v0, v1, beta);
  }
  R = result.refl;
  T = result.refr;

  if (a_ior[layers].im > 0.001)
  {
    vec3 wo = reflect((-1.0f) * wi, wm);
    if (wi.z < 0.f || wo.z <= 0.f)
    {
      return;
    }
    float D = eval_microfacet(wm, alpha, 1);
    float G = microfacet_G(wi, wo, wm, alpha);
    pRes.pdf = wm_pdf.w / (4.0f * abs(dot(wo, wm)));
    pRes.val = pRes.pdf * smith_g1(wo, wm, alpha) * vec4(R) / max(wo.z, EPSILON_32);
    if (reversed)
    {
      wo = -1 * wo;
    }
    pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
    pRes.flags = RAY_FLAG_HAS_NON_SPEC;
    pRes.ior = _extIOR;
  }
  else
  {
    if (rands.w * (R + T) < R)
    {
      vec3 wo = reflect((-1.0f) * wi, wm);
      if (wi.z < 0.f || wo.z <= 0.f)
      {
        return;
      }
      float D = eval_microfacet(wm, alpha, 1);
      pRes.pdf = wm_pdf.w / (4.0f * abs(dot(wo, wm)));
      pRes.val = pRes.pdf * smith_g1(wo, wm, alpha) * vec4(R) / max(wo.z, EPSILON_32);
      pRes.pdf *= R / (R + T);
      if (reversed)
      {
        wo = -1 * wo;
      }
      pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
      pRes.flags = RAY_FLAG_HAS_NON_SPEC;
      pRes.ior = _extIOR;
    }
    else
    {
      vec4 fr = FrDielectricDetailedV2(dot(wi, wm), ior);
      const float cosThetaT = fr.y;
      const float eta_it = fr.z;
      const float eta_ti = fr.w;  

      vec3 ws,  wt;
      CoordinateSystemV2(wm, ws, wt);
      const vec3 local_wi = vec3(dot(ws, wi),dot(wt, wi),dot(wm, wi));
      const vec3 local_wo = refract(local_wi, cosThetaT, eta_ti);
      vec3 wo = normalize(local_wi.x * ws + local_wi.y * wt + local_wi.z * wm);
      if (wo.z > 0.f)
      {
        return;
      }
      float D = eval_microfacet(wm, alpha, 1);
      float G = microfacet_G(wi, wo, wm, alpha);
      float denom = sqr(dot(wo, wm) + dot(wi, wm) / eta_it);
      float dwm_dwi = abs(dot(wo, wm)) / denom;
      pRes.val = D * G * vec4(T) * abs(dot(wi, wm) * dot(wo, wm) / (wi.z * wo.z * denom));
      pRes.pdf = D * dwm_dwi * T / (R + T);
      if (reversed)
      {
        wo = -1 * wo;
      }
      pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
      pRes.flags = RAY_FLAG_HAS_NON_SPEC;;
      pRes.ior = (_extIOR == a_ior[layers].re) ? extIOR : a_ior[layers].re;
    }
  }
}

float evalMap2DPdf_m_pdfLightData(vec2 texCoordT, uint intervalsOffset, const int sizeX, const int sizeY) {  
  const float fw = float(sizeX);
  const float fh = float(sizeY);
  
  //texCoordT.x = WrapVal(texCoordT.x);
  //texCoordT.y = WrapVal(texCoordT.y);

  if (texCoordT.x < 0.0f || texCoordT.x > 1.0f) texCoordT.x -= float((int((texCoordT.x))));
  if (texCoordT.y < 0.0f || texCoordT.x > 1.0f) texCoordT.y -= float((int((texCoordT.y))));

  int pixelX = int((fw*texCoordT.x - 0.5f));
  int pixelY = int((fh*texCoordT.y - 0.5f));

  if (pixelX >= sizeX) pixelX = sizeX - 1;
  if (pixelY >= sizeY) pixelY = sizeY - 1;

  if (pixelX < 0) pixelX += sizeX;
  if (pixelY < 0) pixelY += sizeY;

  const int pixelOffset = pixelY*sizeX + pixelX;
  const int maxSize     = sizeX*sizeY;
  const int offset0     = (pixelOffset + 0 < maxSize+0) ? pixelOffset + 0 : maxSize - 1;
  const int offset1     = (pixelOffset + 1 < maxSize+1) ? pixelOffset + 1 : maxSize;

  const vec2 interval = vec2(m_pdfLightData[offset0 + intervalsOffset], m_pdfLightData[offset1 + intervalsOffset]);
  
  return (interval.y - interval.x)*(fw*fh)/m_pdfLightData[sizeX*sizeY + intervalsOffset];
}

void filmSmoothSampleAndEval_m_materials_m_films_thickness_vec_m_precomp_thin_films(uint a_materialsOffset,  uint thicknessOffset, uint layers, const vec4 a_wavelengths, const float _extIOR, vec4 rands, vec3 v, vec3 n, vec2 tc, inout BsdfSample pRes, uint precomputed_dataOffset) {
  const float extIOR = m_materials[0 + a_materialsOffset].data[FILM_ETA_EXT];

  bool reversed = false;
  uint32_t refl_offset;
  uint32_t refr_offset;
  if ((pRes.flags & RAY_FLAG_HAS_INV_NORMAL) != 0) // inside of object
  {
    n = -1 * n;
  }
  if (dot(n, v) < 0.f && a_ior[layers].im < 0.001)
  {
    reversed = true;
    refl_offset = FILM_ANGLE_RES * FILM_LENGTH_RES * 2;
    refr_offset = FILM_ANGLE_RES * FILM_LENGTH_RES * 3;
  }
  else
  {
    refl_offset = 0;
    refr_offset = FILM_ANGLE_RES * FILM_LENGTH_RES;
  }

  vec3 s, t = n;
  CoordinateSystemV2(n, s, t);
  vec3 wi = vec3(dot(v, s),dot(v, t),dot(v, n));

  float cosThetaI = clamp(abs(wi.z), 0.0001, 1.0f);

  float ior = a_ior[layers].re / extIOR;
  
  float R, T;
  FrReflRefr result = {0.f, 0.f};

  uint precompFlag = floatBitsToUint(m_materials[0 + a_materialsOffset].data[FILM_PRECOMP_FLAG]);
  if (precompFlag == 0u)
  {
    if (layers == 2)
    {
      if (!reversed)
      {
        result = FrFilm(cosThetaI, a_ior[0], a_ior[1], a_ior[2], m_films_thickness_vec[0 + thicknessOffset], a_wavelengths[0]);
      }
      else
      {
        result = FrFilm(cosThetaI, a_ior[2], a_ior[1], a_ior[0], m_films_thickness_vec[0 + thicknessOffset], a_wavelengths[0]);
      }
    }
    else if (layers > 2)
    {
      if (!reversed)
      { 
        //result = multFrFilm(cosThetaI, a_ior, thickness, layers, a_wavelengths[0]);
        complex a_cosTheta[KSPEC_FILMS_STACK_SIZE + 1];
        complex a_phaseDiff[KSPEC_FILMS_STACK_SIZE - 1];
        a_cosTheta[0] = to_complex(cosThetaI);

        float sinThetaI = 1.0f - cosThetaI * cosThetaI;
        complex sinTheta;
        complex cosTheta;
        for (uint i = 1; i <= layers; ++i)
        {
          sinTheta = real_div_complex(sinThetaI * a_ior[0].re * a_ior[0].re,(complex_mul(make_complex(a_ior[i].re,a_ior[i].im),a_ior[i])));
          cosTheta = complex_sqrt(real_sub_complex(1.0f,sinTheta));
          a_cosTheta[i] = cosTheta;
          if (i < layers)
            a_phaseDiff[i - 1] = filmPhaseDiff(cosTheta, a_ior[i], m_films_thickness_vec[i - 1 + thicknessOffset], a_wavelengths[0]);
        }
        uint polarization[2] = {PolarizationS, PolarizationP};
        for (uint p = 0; p < 2; ++p)
        {
          complex FrRefl = FrComplexRefl(a_cosTheta[layers - 1], a_cosTheta[layers], a_ior[layers - 1], a_ior[layers], p);
          complex FrRefr = FrComplexRefr(a_cosTheta[layers - 1], a_cosTheta[layers], a_ior[layers - 1], a_ior[layers], p);
          for (uint i = layers - 1; i > 0; --i)
          {
            complex FrReflI = FrComplexRefl(a_cosTheta[i - 1], a_cosTheta[i], a_ior[i - 1], a_ior[i], p);
            complex FrRefrI = FrComplexRefr(a_cosTheta[i - 1], a_cosTheta[i], a_ior[i - 1], a_ior[i], p);
            complex temp_exp = real_mul_complex(exp(-a_phaseDiff[i - 1].im / 2.f),make_complex(cos(a_phaseDiff[i - 1].re / 2.f),sin(a_phaseDiff[i - 1].re / 2.f)));
            FrRefr = complex_mul(complex_mul(FrRefrI,FrRefr),temp_exp);
            FrRefl = complex_mul(complex_mul(FrRefl,temp_exp),temp_exp);
            complex denom = real_div_complex(1.f,(real_add_complex(1,complex_mul(FrReflI,FrRefl))));
            FrRefr = complex_mul(FrRefr,denom);
            FrRefl = complex_mul((complex_add(FrReflI,FrRefl)),denom);
          }
          result.refl += complex_norm(FrRefl) / 2;
          result.refr += complex_norm(FrRefr) / 2;
        }
        result.refr *= getRefractionFactor(cosThetaI, a_cosTheta[layers], a_ior[0], a_ior[layers]);
      }
      else
      {
        //result = multFrFilm_r(cosThetaI, a_ior, thickness, layers, a_wavelengths[0]);
        complex a_cosTheta[KSPEC_FILMS_STACK_SIZE + 1];
        complex a_phaseDiff[KSPEC_FILMS_STACK_SIZE - 1];
        a_cosTheta[layers] = to_complex(cosThetaI);

        float sinThetaI = 1.0f - cosThetaI * cosThetaI;
        complex sinTheta = to_complex(1.0);
        complex cosTheta = to_complex(1.0);
        for (uint i = layers; i > 0; --i)
        {
          sinTheta = real_div_complex(sinThetaI * a_ior[layers].re * a_ior[layers].re,(complex_mul(make_complex(a_ior[i - 1].re,a_ior[i - 1].im),a_ior[i - 1])));
          cosTheta = complex_sqrt(real_sub_complex(1.0f,sinTheta));
          a_cosTheta[i - 1] = cosTheta;
          if (i > 1)
            a_phaseDiff[i - 2] = filmPhaseDiff(cosTheta, a_ior[i - 1], m_films_thickness_vec[i - 2 + thicknessOffset], a_wavelengths[0]);
        }
        uint polarization[2] = {PolarizationS, PolarizationP};
        for (uint p = 0; p < 2; ++p)
        {
          complex FrRefl = FrComplexRefl(a_cosTheta[1], a_cosTheta[0], a_ior[1], a_ior[0], p);
          complex FrRefr = FrComplexRefr(a_cosTheta[1], a_cosTheta[0], a_ior[1], a_ior[0], p);
          for (uint i = 1; i < layers; ++i)
          {
            complex FrReflI = FrComplexRefl(a_cosTheta[i + 1], a_cosTheta[i], a_ior[i + 1], a_ior[i], p);
            complex FrRefrI = FrComplexRefr(a_cosTheta[i + 1], a_cosTheta[i], a_ior[i + 1], a_ior[i], p);
            complex temp_exp = real_mul_complex(exp(-a_phaseDiff[i - 1].im / 2.f),make_complex(cos(a_phaseDiff[i - 1].re / 2.f),sin(a_phaseDiff[i - 1].re / 2.f)));
            FrRefr = complex_mul(complex_mul(FrRefrI,FrRefr),temp_exp);
            FrRefl = complex_mul(complex_mul(FrRefl,temp_exp),temp_exp);
            complex denom = real_div_complex(1.f,(real_add_complex(1,complex_mul(FrReflI,FrRefl))));
            FrRefr = complex_mul(FrRefr,denom);
            FrRefl = complex_mul((complex_add(FrReflI,FrRefl)),denom);
          }
          result.refl += complex_norm(FrRefl) / 2;
          result.refr += complex_norm(FrRefr) / 2;
        }
        result.refr *= getRefractionFactor(cosThetaI, a_cosTheta[layers], a_ior[layers], a_ior[0]);
      }
    } 
  }
  else
  {
    float w = clamp((a_wavelengths[0] - LAMBDA_MIN) / (LAMBDA_MAX - LAMBDA_MIN), 0.f, 1.f);
    float theta = clamp(acos(cosThetaI) * 2.f / M_PI, 0.f, 1.f);
    //result.refl = lerp_gather_2d(reflectance, w, theta, FILM_LENGTH_RES, FILM_ANGLE_RES);
    //result.refr = lerp_gather_2d(transmittance, w, theta, FILM_LENGTH_RES, FILM_ANGLE_RES);
    w *= FILM_LENGTH_RES - 1;
    theta *= FILM_ANGLE_RES - 1;
    uint index1 = min(uint32_t(w), uint32_t(FILM_LENGTH_RES - 2));
    uint index2 = min(uint32_t(theta), uint32_t(FILM_ANGLE_RES - 2));

    float alpha = w - float(index1);
    float beta = theta - float(index2);

    float v0 = mix(m_precomp_thin_films[refl_offset + index1 * FILM_ANGLE_RES + index2 + precomputed_dataOffset], m_precomp_thin_films[refl_offset + (index1 + 1) * FILM_ANGLE_RES + index2 + precomputed_dataOffset], alpha);
    float v1 = mix(m_precomp_thin_films[refl_offset + index1 * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], m_precomp_thin_films[refl_offset + (index1 + 1) * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], alpha);
    result.refl = mix(v0, v1, beta);

    v0 = mix(m_precomp_thin_films[refr_offset + index1 * FILM_ANGLE_RES + index2 + precomputed_dataOffset], m_precomp_thin_films[refr_offset + (index1 + 1) * FILM_ANGLE_RES + index2 + precomputed_dataOffset], alpha);
    v1 = mix(m_precomp_thin_films[refr_offset + index1 * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], m_precomp_thin_films[refr_offset + (index1 + 1) * FILM_ANGLE_RES + index2 + 1 + precomputed_dataOffset], alpha);
    result.refr = mix(v0, v1, beta);
  }
  R = result.refl;
  T = result.refr;

  if (a_ior[layers].im > 0.001)
  {
    vec3 wo = vec3(-wi.x,-wi.y,wi.z);
    pRes.val = vec4(R);
    pRes.pdf = 1.f;
    pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
    pRes.flags |= RAY_EVENT_S;
    pRes.ior = _extIOR;
  }
  else
  {
    if (rands.x * (R + T) < R)
    {
      vec3 wo = vec3(-wi.x,-wi.y,wi.z);
      pRes.val = vec4(R);
      pRes.pdf = R / (R + T);
      pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
      pRes.flags |= RAY_EVENT_S;
      pRes.ior = _extIOR;
    }
    else
    {
      vec4 fr = FrDielectricDetailedV2(wi.z, ior);
      const float cosThetaT = fr.y;
      const float eta_ti = fr.w;  

      vec3 wo = refract(wi, cosThetaT, eta_ti);
      pRes.val = vec4(T);
      pRes.pdf = T / (R + T);
      pRes.dir = normalize(wo.x * s + wo.y * t + wo.z * n);
      pRes.flags |= (RAY_EVENT_S | RAY_EVENT_T);
      pRes.ior = (_extIOR == a_ior[layers].re) ? extIOR : a_ior[layers].re;
    }
  }

  pRes.val /= max(abs(dot(pRes.dir, n)), 1e-6f);
}

LightSample sphereLightSampleRev_m_lights(uint a_pLightOffset, vec2 rands) {
  const float theta = 2.0f * M_PI * rands.x;
  const float phi   = acos(1.0f - 2.0f * rands.y);
  const float x     = sin(phi) * cos(theta);
  const float y     = sin(phi) * sin(theta);
  const float z     = cos(phi);
  const vec3 lcenter = m_lights[0 + a_pLightOffset].pos.xyz;
  const float  lradius   = m_lights[0 + a_pLightOffset].size.x;
  const vec3 samplePos = lcenter + (lradius*1.000001f)*vec3(x, y, z);
  LightSample res;
  res.pos  = samplePos;
  res.norm = normalize(samplePos - lcenter);
  res.isOmni = false;
  res.hasIES = (m_lights[0 + a_pLightOffset].iesId != uint(-1));
  res.pdf    = 1.0f; // evaluated later 
  return res;
}

int SelectIndexPropToOpt_m_pdfLightData(const float a_r, uint a_accumOffset, const int N, inout float pPDF) {
  int leftBound  = 0;
  int rightBound = N - 2; // because a_accum[N-1] == summ(a_accum[0 .. N-2]).
  int counter    = 0;
  int currPos    = -1;

  const int maxStep = 50;
  const float x = a_r*m_pdfLightData[N - 1 + a_accumOffset];

  while (rightBound - leftBound > 1 && counter < maxStep)
  {
    const int currSize = rightBound + leftBound;
    const int currPos1 = (currSize % 2 == 0) ? (currSize + 1) / 2 : (currSize + 0) / 2;

    const float a = m_pdfLightData[currPos1 + 0 + a_accumOffset];
    const float b = m_pdfLightData[currPos1 + 1 + a_accumOffset];

    if (a < x && x <= b)
    {
      currPos = currPos1;
      break;
    }
    else if (x <= a)
      rightBound = currPos1;
    else if (x > b)
      leftBound = currPos1;

    counter++;
  }

  if (currPos < 0) // check the rest intervals
  {
    const float a1 = m_pdfLightData[leftBound + 0 + a_accumOffset];
    const float b1 = m_pdfLightData[leftBound + 1 + a_accumOffset];
    const float a2 = m_pdfLightData[rightBound + 0 + a_accumOffset];
    const float b2 = m_pdfLightData[rightBound + 1 + a_accumOffset];
    if (a1 < x && x <= b1)
      currPos = leftBound;
    if (a2 < x && x <= b2)
      currPos = rightBound;
  }

  if (x == 0.0f)
    currPos = 0;
  else if (currPos < 0)
    currPos = (rightBound + leftBound + 1) / 2;

  (pPDF) = (m_pdfLightData[currPos + 1 + a_accumOffset] - m_pdfLightData[currPos + a_accumOffset]) / m_pdfLightData[N - 1 + a_accumOffset];
  return currPos;
}

vec3 SpectrumToXYZ_m_cie_x_m_cie_y_m_cie_z(vec4 spec, vec4 lambda, float lambda_min, float lambda_max, uint a_CIE_XOffset, uint a_CIE_YOffset, uint a_CIE_ZOffset, bool terminate_waves) {
  vec4 pdf = vec4(1.0f / (lambda_max - lambda_min));
  const float CIE_Y_integral = 106.856895f;
  const uint nCIESamples = 471;

  if(terminate_waves)
  {
    pdf[0] /= float(SPECTRUM_SAMPLE_SZ);
    for(uint i = 1; i < SPECTRUM_SAMPLE_SZ; ++i)
    {
      pdf[int(i)] = 0.0f;
    }
  }
  
  for (uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
  {
    spec[int(i)] = (pdf[int(i)] != 0) ? spec[int(i)] / pdf[int(i)] : 0.0f;
  }
  
  //float4 X = SampleCIE(lambda, a_CIE_X, lambda_min, lambda_max);
  //float4 Y = SampleCIE(lambda, a_CIE_Y, lambda_min, lambda_max);
  //float4 Z = SampleCIE(lambda, a_CIE_Z, lambda_min, lambda_max);
  vec4 X,  Y,  Z; 
  for (uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i) 
  {
    uint offset = uint32_t(float(floor(lambda[int(i)] + 0.5f)) - lambda_min);
  
    if (offset >= nCIESamples)
      X[int(i)] = 0;
    else
      X[int(i)] = m_cie_x[offset + a_CIE_XOffset];
  
    if (offset >= nCIESamples)
      Y[int(i)] = 0;
    else
      Y[int(i)] = m_cie_y[offset + a_CIE_YOffset];
  
    if (offset >= nCIESamples)
      Z[int(i)] = 0;
    else
      Z[int(i)] = m_cie_z[offset + a_CIE_ZOffset];
  }

  for (uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
  {
    X[int(i)] *= spec[int(i)];
    Y[int(i)] *= spec[int(i)];
    Z[int(i)] *= spec[int(i)];
  }

  float x = SpectrumAverage(X) / CIE_Y_integral;
  float y = SpectrumAverage(Y) / CIE_Y_integral;
  float z = SpectrumAverage(Z) / CIE_Y_integral;

  return vec3(x,y,z);
}

void conductorRoughEval_m_materials(uint a_materialsOffset, const vec4 etaSpec, const vec4 kSpec, vec3 l, vec3 v, vec3 n, vec2 tc, vec3 alpha_tex, inout BsdfEval pRes) {
  const vec2 alpha = vec2(min(m_materials[0 + a_materialsOffset].data[CONDUCTOR_ROUGH_U], alpha_tex.x),min(m_materials[0 + a_materialsOffset].data[CONDUCTOR_ROUGH_V], alpha_tex.y));

  const vec4 rgb_reflectance = m_materials[0 + a_materialsOffset].colors[CONDUCTOR_COLOR];

  vec3 nx,  ny, nz = n;
  CoordinateSystemV2(nz, nx, ny);

  // v = (-1.0f) * v;
  const vec3 wo = vec3(dot(v, nx),dot(v, ny),dot(v, nz));
  const vec3 wi = vec3(dot(l, nx),dot(l, ny),dot(l, nz));

  if(wo.z * wi.z < 0.0f)
    return;

  vec3 wm = wo + wi;
  if (dot(wm, wm) == 0)
      return;

  wm = normalize(wm);
  vec4 val;
  for(uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i)
  {
    val[int(i)] = conductorRoughEvalInternal(wo, wi, wm, alpha, make_complex(etaSpec[int(i)],kSpec[int(i)]));
  }

  pRes.val = val * rgb_reflectance;

  wm        = FaceForward(wm, vec3(0.0f,0.0f,1.0f));
  pRes.pdf = trPDF(wo, wm, alpha) / (4.0f * abs(dot(wo, wm)));
}

LightSample directLightSampleRev_m_lights(uint a_pLightOffset, vec2 rands, vec3 illuminationPoint) {
  const vec3 norm = m_lights[0 + a_pLightOffset].norm.xyz;
  LightSample res;
  res.pos    = illuminationPoint - norm*100000.0f;
  res.norm   = norm;
  res.isOmni = false;
  res.hasIES = false;
  res.pdf    = 1.0f; // evaluated later 
  return res;
}

void gltfEval_m_materials(uint a_materialsOffset, vec3 l, vec3 v, vec3 n, vec2 tc, vec4 baseColor, vec4 fourParams, inout BsdfEval res) {
  const uint   cflags     = m_materials[0 + a_materialsOffset].cflags;
  const vec4 metalCol = m_materials[0 + a_materialsOffset].colors[GLTF_COLOR_METAL]*baseColor;
  const vec4 coatCol = m_materials[0 + a_materialsOffset].colors[GLTF_COLOR_COAT];
  const float  roughness  = clamp(1.0f - m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_GLOSINESS]*fourParams.x, 0.0f, 1.0f);
        float  metalness  = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_ALPHA]*fourParams.y;
  const float  coatValue  = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_REFL_COAT]*fourParams.z;      
  const float  fresnelIOR = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_IOR];

  if(cflags == GLTF_COMPONENT_METAL) // assume only GGX-based metal
    metalness = 1.0f;
      
  float ggxVal, ggxPdf, VdotH; 
  if(roughness != 0.0f) // perfect specular reflection in coating layer
  {
    ggxVal = ggxEvalBSDF(l, v, n, roughness);
    ggxPdf = ggxEvalPDF (l, v, n, roughness);
    VdotH  = dot(v,normalize(v + l));
  }
  else
  {
    ggxVal = 0.0f;
    ggxPdf = 0.0f;
    VdotH  = dot(v,n);
  }

  float lambertVal       = lambertEvalBSDF(l, v, n);
  const float lambertPdf = lambertEvalPDF (l, v, n);
  float f_i              = 1.0f;
  float coeffLambertPdf  = 1.0f;
      
  if(coatValue > 0.0f && metalness < 1.0f && fresnelIOR > 0.0f) // Plastic, account for retroreflection between surface and coating layer
  {
    f_i                   = FrDielectricPBRT(abs(dot(v,n)), 1.0f, fresnelIOR);
    const float f_o       = FrDielectricPBRT(abs(dot(l,n)), 1.0f, fresnelIOR);  
    const float m_fdr_int = m_materials[0 + a_materialsOffset].data[GLTF_FLOAT_MI_FDR_INT];
    const float coeff     = mix(1.0f, (1.f - f_i) * (1.f - f_o) / (fresnelIOR*fresnelIOR*(1.f - m_fdr_int)), coatValue);
    lambertVal           *= coeff;
    coeffLambertPdf       = coeff; 
  }
  
  const vec4 fConductor = hydraFresnelCond(metalCol, VdotH, fresnelIOR, roughness); // (1) eval metal component      
  const vec4 specularColor = ggxVal*fConductor;                                        // eval metal specular component

  const float prob_specular = 0.5f*coatValue;
  const float prob_diffuse  = 1.0f-prob_specular;

  const vec4 dielectricVal = lambertVal * baseColor + ggxVal * coatCol * f_i * coatValue;
  const float  dielectricPdf = lambertPdf * prob_diffuse + ggxPdf*prob_specular; 

  res.val = metalness * specularColor + (1.0f - metalness) * dielectricVal; // (3) accumulate final color and pdf
  res.pdf = metalness * ggxPdf        + (1.0f - metalness) * dielectricPdf; // (3) accumulate final color and pdf
}

LightSample pointLightSampleRev_m_lights(uint a_pLightOffset) {
  LightSample res;
  res.pos    = m_lights[0 + a_pLightOffset].pos.xyz;
  res.norm   = m_lights[0 + a_pLightOffset].norm.xyz;
  res.isOmni = (m_lights[0 + a_pLightOffset].distType == LIGHT_DIST_OMNI);
  res.hasIES = (m_lights[0 + a_pLightOffset].iesId != uint(-1));
  res.pdf    = 1.0f; // evaluated later 
  return res;
}

void glassEval_m_materials(uint a_materialsOffset, vec3 l, vec3 v, vec3 n, vec2 tc, vec3 color, inout BsdfEval res) {
  // because we don't want to sample this material with shadow rays
  res.val   = vec4(0.0f);
  res.pdf   = 0.0f;
}

LightSample areaLightSampleRev_m_lights(uint a_pLightOffset, vec2 rands) {
  vec2 sampleOff = 2.0f * (vec2(-0.5f,-0.5f) + rands) * m_lights[0 + a_pLightOffset].size;  // PLEASE! use 'a_pLight[0].' for a while ... , not a_pLight-> and not *(a_pLight[0])
  if(m_lights[0 + a_pLightOffset].geomType == LIGHT_GEOM_DISC)
  {
    const float offsetX = rands.x * 2.0f - 1.0f;
    const float offsetY = rands.y * 2.0f - 1.0f;
    sampleOff = MapSamplesToDisc(vec2(offsetX,offsetY))*m_lights[0 + a_pLightOffset].size.x; 
  }
  const vec3 samplePos = mul3x3(m_lights[0 + a_pLightOffset].matrix, vec3(sampleOff.x,0.0f,sampleOff.y)) + m_lights[0 + a_pLightOffset].pos.xyz + epsilonOfPos(m_lights[0 + a_pLightOffset].pos.xyz) * m_lights[0 + a_pLightOffset].norm.xyz;
  LightSample res;
  res.pos    = samplePos;
  res.norm   = m_lights[0 + a_pLightOffset].norm.xyz;
  res.isOmni = false;
  res.hasIES = (m_lights[0 + a_pLightOffset].iesId != uint(-1));
  res.pdf    = 1.0f; // evaluated later 
  return res;
}

void RecordBlendRndNeeded(uint bounceId, uint layer, float rand) {}

float GetRandomNumbersMatB(uint tid, inout RandomGen a_gen, int a_bounce, int a_layer) { return rndFloat1_Pseudo(a_gen); }

bool IntersectSphericalElement(float radius, float zCenter, vec3 rayPos, vec3 rayDir, inout float t, inout vec3 n) {
  // Compute _t0_ and _t1_ for ray--element intersection
  const vec3 o = rayPos - vec3(0,0,zCenter);
  const float  A = rayDir.x * rayDir.x + rayDir.y * rayDir.y + rayDir.z * rayDir.z;
  const float  B = 2 * (rayDir.x * o.x + rayDir.y * o.y + rayDir.z * o.z);
  const float  C = o.x * o.x + o.y * o.y + o.z * o.z - radius * radius;
  float  t0, t1;
  if (!Quadratic(A, B, C, t0, t1)) 
    return false;
  
  // Select intersection $t$ based on ray direction and element curvature
  bool useCloserT = (rayDir.z > 0.0f) != (radius < 0.0);
  t = useCloserT ? min(t0, t1) : max(t0, t1);
  if (t < 0.0f) 
    return false;
  
  // Compute surface normal of element at ray intersection point
  n = normalize(o + (t)*rayDir);
  n = faceforward(n, -1.0f*rayDir);
  return true;
}

bool terminateWavelngths(uint a_flags) { return (a_flags & RAY_FLAG_WAVES_DIVERGED)   != 0; }

void RecordPixelRndIfNeeded(vec2 offsets, float u) {}

vec4 GetRandomNumbersMats(uint tid, inout RandomGen a_gen, int a_bounce) { return rndFloat4_Pseudo(a_gen); }

vec4 SampleMatColorSpectrumTexture(uint matId, vec4 a_wavelengths, uint paramId, uint paramSpecId, vec2 texCoords) {  
  vec4 res = m_materials[matId].colors[paramId];
  if(a_wavelengths[0] == 0.0f)
    return res;

  const uint specId = m_materials[matId].spdid[paramSpecId];
  if(specId < 0xFFFFFFFF)
  {
    const uvec2 data = m_spec_offset_sz[specId];
    const uint  offset = data.x;
    const uint  size   = data.y;
    
    if(size > 0) // sample SPD
    {
      res = SampleUniformSpectrum_m_spec_values(offset, a_wavelengths, size);
    }
    else // check if spectrum is represented as textures
    {
      const uvec2 tex_data = m_spec_tex_offset_sz[specId];
      const uint tex_offset = tex_data.x;
      const uint tex_size   = tex_data.y;
      if(tex_size > 0)
      {
        for(int i = 0; i < 4; ++i)
        {
          if (a_wavelengths[i] < float(m_spec_tex_ids_wavelengths[tex_offset].y) ||
              a_wavelengths[i] > float(m_spec_tex_ids_wavelengths[tex_offset + tex_size - 1].y) )
          {
            res[i] = 0.0f;
            continue;
          }

          uint o = BinarySearchU2_m_spec_tex_ids_wavelengths(tex_offset, tex_size, a_wavelengths[i]);

          uint texID1 = m_spec_tex_ids_wavelengths[tex_offset + o + 0].x;
          uint texID2 = m_spec_tex_ids_wavelengths[tex_offset + o + 1].x;

          const vec2 texCoordT = mulRows2x4(m_materials[matId].row0[0], m_materials[matId].row1[0], texCoords);
          const vec4 texColor1 = texture(m_textures[texID1], texCoordT);
          const vec4 texColor2 = texture(m_textures[texID2], texCoordT);
  
          float t = (a_wavelengths[i] - float(m_spec_tex_ids_wavelengths[tex_offset + o].y)) / 
                    float(m_spec_tex_ids_wavelengths[tex_offset + o + 1].y - m_spec_tex_ids_wavelengths[tex_offset + o].y );
                    
          vec4 outColor = mix(texColor1, texColor2, t);

          res[i] = outColor.x;
        }
      }
    }
  }

  return res;
}

MatIdWeightPair BlendEval(MatIdWeight a_mat, vec4 wavelengths, vec3 l, vec3 v, vec3 n, vec2 tc) {
  const vec2 texCoordT = mulRows2x4(m_materials[a_mat.id].row0[0], m_materials[a_mat.id].row1[0], tc);
  const uint   texId     = m_materials[a_mat.id].texid[0];
  const vec4 weightDat = texture(m_textures[texId], texCoordT);
  
  const float  weightTex = weightDat.x;
  const float  weight    = m_materials[a_mat.id].data[BLEND_WEIGHT] * weightTex;

  const uint matId1      = m_materials[a_mat.id].datai[0];
  const uint matId2      = m_materials[a_mat.id].datai[1];

  MatIdWeight p1, p2;
  p1.id     = matId1;
  p1.weight = a_mat.weight * (1.0f - weight);
  p2.id     = matId2;
  p2.weight = a_mat.weight * weight;

  return make_weight_pair(p1, p2);
}

vec4 GetRandomNumbersLens(uint tid, inout RandomGen a_gen) { return rndFloat4_Pseudo(a_gen); }

float GetRandomNumbersTime(uint tid, inout RandomGen a_gen) { return rndFloat1_Pseudo(a_gen); }

float GetRandomNumbersSpec(uint tid, inout RandomGen a_gen) { return rndFloat1_Pseudo(a_gen); }

bool TraceLensesFromFilm(inout vec3 inoutRayPos, inout vec3 inoutRayDir) {
  float elementZ = 0;
  // Transform _rCamera_ from camera to lens system space
  // 
  vec3 rayPosLens = vec3(inoutRayPos.x,inoutRayPos.y,-inoutRayPos.z);
  vec3 rayDirLens = vec3(inoutRayDir.x,inoutRayDir.y,-inoutRayDir.z);

  for(int i=0; i<ubo.lines_size; i++)
  {
    const LensElementInterface element = lines[i];                                  
    // Update ray from film accounting for interaction with _element_
    elementZ -= element.thickness;
    
    // Compute intersection of ray with lens element
    float t;
    vec3 n;
    bool isStop = (element.curvatureRadius == 0.0f);
    if (isStop) 
    {
      // The refracted ray computed in the previous lens element
      // interface may be pointed towards film plane(+z) in some
      // extreme situations; in such cases, 't' becomes negative.
      if (rayDirLens.z >= 0.0f) 
        return false;
      t = (elementZ - rayPosLens.z) / rayDirLens.z;
    } 
    else 
    {
      const float radius  = element.curvatureRadius;
      const float zCenter = elementZ + element.curvatureRadius;
      if (!IntersectSphericalElement(radius, zCenter, rayPosLens, rayDirLens, t, n))
        return false;
    }

    // Test intersection point against element aperture
    const vec3 pHit = rayPosLens + t*rayDirLens;
    const float r2    = pHit.x * pHit.x + pHit.y * pHit.y;
    if (r2 > element.apertureRadius * element.apertureRadius) 
      return false;
    
    rayPosLens = pHit;
    // Update ray path for from-scene element interface interaction
    if (!isStop) 
    {
      vec3 wt;
      float etaI = lines[i+0].eta;                                                      
      float etaT = (i == ubo.lines_size-1) ? 1.0f : lines[i+1].eta;
      if(etaT == 0.0f)
        etaT = 1.0f;                                                          
      if (!Refract(normalize((-1.0f)*rayDirLens), n, etaI / etaT, wt))
        return false;
      rayDirLens = wt;
    }

  }

  // Transform _rLens_ from lens system space back to camera space
  //
  inoutRayPos = vec3(rayPosLens.x,rayPosLens.y,-rayPosLens.z);
  inoutRayDir = vec3(rayDirLens.x,rayDirLens.y,-rayDirLens.z);
  return true;  
}

Map2DPiecewiseSample SampleMap2D(vec3 rands, uint a_tableOffset, int sizeX, int sizeY) {
  const float fw = float(sizeX);
  const float fh = float(sizeY);
  const float fN = fw*fh;

  float pdf = 1.0f;
  int pixelOffset = SelectIndexPropToOpt_m_pdfLightData(rands.z, a_tableOffset, sizeX*sizeY+1, pdf);

  if (pixelOffset >= sizeX*sizeY)
    pixelOffset = sizeX*sizeY - 1;

  const int yPos = pixelOffset / sizeX;
  const int xPos = pixelOffset - yPos*sizeX;

  const float texX = (1.0f / fw)*((float((xPos)) + 0.5f) + (rands.x*2.0f - 1.0f)*0.5f);
  const float texY = (1.0f / fh)*((float((yPos)) + 0.5f) + (rands.y*2.0f - 1.0f)*0.5f);

  Map2DPiecewiseSample result;
  result.mapPdf   = pdf*fN; 
  result.texCoord = vec2(texX, texY);
  return result;
}

float LensRearZ() { return lines[0].thickness; }

float LensRearRadius() { return lines[0].apertureRadius; }

vec3 BumpMapping(uint normalMapId, uint currMatId, vec3 n, vec3 tan, vec2 tc) {
  const uint   mflags    = m_materials[currMatId].cflags;
  const vec2 texCoordT = mulRows2x4(m_materials[currMatId].row0[1], m_materials[currMatId].row1[1], tc);
  const vec4 normalTex = texture(m_textures[normalMapId], texCoordT);
  const vec3 normalTS = NormalMapTransform(mflags, normalTex.xyz);
  
  const vec3 bitan = cross(n, tan);
  const mat3 tangentTransform = make_float3x3(tan, bitan, n);

  return normalize(inverse(tangentTransform)*normalTS);
}

uint BlendSampleAndEval(uint a_materialId, uint tid, uint bounce, uint layer, vec4 wavelengths, inout RandomGen a_gen, vec3 v, vec3 n, vec2 tc, inout MisData a_misPrev, inout BsdfSample a_pRes) {
  const vec2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const uint   texId     = m_materials[a_materialId].texid[0];
  const vec4 weightDat = texture(m_textures[texId], texCoordT);
  const float  weightTex = weightDat.x;
  const float  weight    = m_materials[a_materialId].data[BLEND_WEIGHT] * weightTex;

  const uint matId1 = m_materials[a_materialId].datai[0];
  const uint matId2 = m_materials[a_materialId].datai[1];

  uint selectedMatId = matId1;
  const float select = GetRandomNumbersMatB(tid, a_gen, int(bounce), int(layer));
  RecordBlendRndNeeded(bounce, layer, select);

  if(select < weight)
  {
    a_pRes.pdf *= weight;
    a_pRes.val *= weight;
    selectedMatId = matId2;
  }
  else
  {
    a_pRes.pdf *= 1.0f - weight;
    a_pRes.val *= 1.0f - weight;
    selectedMatId = matId1;
  }

  return selectedMatId;
}

vec4 SampleMatParamSpectrum(uint matId, vec4 a_wavelengths, uint paramId, uint paramSpecId) {  
  vec4 res = vec4(m_materials[matId].data[paramId]);
  if(a_wavelengths[0] == 0.0f)
    return res;

  const uint specId = m_materials[matId].spdid[paramSpecId];
  if(specId < 0xFFFFFFFF)
  {
    const uvec2 data = m_spec_offset_sz[specId];
    const uint offset = data.x;
    const uint size   = data.y;
    //res = SampleSpectrum(m_wavelengths.data() + offset, m_spec_values.data() + offset, a_wavelengths, size);
    res = SampleUniformSpectrum_m_spec_values(offset, a_wavelengths, size);
  }

  return res;
}

void RecordMatRndNeeded(uint bounceId, vec4 rands) {}

vec4 SampleFilmsSpectrum(uint matId, vec4 a_wavelengths, uint paramId, uint paramSpecId, uint layer) {  
  vec4 res = vec4(m_films_eta_k_vec[floatBitsToUint(m_materials[matId].data[paramId]) + layer]);
  if(a_wavelengths[0] == 0.0f)
    return res;

  //const uint specId = m_films_eta_id_vec[as_uint(m_materials[a_materialId].data[FILM_ETA_SPECID_OFFSET]) + layer];
  const uint specId = m_films_spec_id_vec[floatBitsToUint(m_materials[matId].data[paramSpecId]) + layer];
  if(specId < 0xFFFFFFFF)
  {
    const uvec2 data = m_spec_offset_sz[specId];
    const uint offset = data.x;
    const uint size   = data.y;
    res = SampleUniformSpectrum_m_spec_values(offset, a_wavelengths, size);
  }

  return res;
}

float LightPdfSelectRev(int a_lightId) { 
  return 1.0f/float(ubo.m_lights_size); // uniform select
}

vec4 EnvironmentColor(vec3 a_dir, inout float outPdf) {
  vec4 color = ubo.m_envColor;
  
  // apply tex color
  //
  const uint envTexId = ubo.m_envTexId;
  if(KSPEC_LIGHT_ENV != 0 && envTexId != uint(-1))
  {
    float sinTheta  = 1.0f;
    const vec2 tc = sphereMapTo2DTexCoord(a_dir, sinTheta);
    const vec2 texCoordT = mulRows2x4(ubo.m_envSamRow0, ubo.m_envSamRow1, tc);
    
    if (sinTheta != 0.f && ubo.m_envEnableSam != 0 && ubo.m_intergatorType == INTEGRATOR_MIS_PT && ubo.m_envLightId != uint(-1))
    {
      const uint offset = m_lights[ubo.m_envLightId].pdfTableOffset;
      const uint sizeX = m_lights[ubo.m_envLightId].pdfTableSizeX;
      const uint sizeY = m_lights[ubo.m_envLightId].pdfTableSizeY;

      // apply inverse texcoord transform to get phi and theta and than get correct pdf from table 
      //
      const float mapPdf = evalMap2DPdf_m_pdfLightData(texCoordT, offset, int(sizeX), int(sizeY));
      outPdf = (mapPdf * 1.0f) / (2.f * M_PI * M_PI * max(abs(sinTheta), 1e-20f));  
    }

    const vec4 texColor = texture(m_textures[envTexId], texCoordT); 
    color *= texColor; 
  }

  return color;
}

bool isOutOfScene(uint a_flags) { return (a_flags & RAY_FLAG_OUT_OF_SCENE)   != 0; }

BsdfSample MaterialSampleWhitted(uint a_materialId, vec3 v, vec3 n, vec2 tc) { 
  const vec4 specular = m_materials[a_materialId].colors[GLTF_COLOR_METAL];
  const vec4 coat = m_materials[a_materialId].colors[GLTF_COLOR_COAT];
  float alpha            = m_materials[a_materialId].data[GLTF_FLOAT_ALPHA];
  
  const vec3 pefReflDir = reflect((-1.0f)*v, n);
  const vec4 reflColor = alpha*specular + (1.0f - alpha)*coat;

  //if(a_materialId == 4)
  //{
  //  int a = 2;
  //}

  BsdfSample res;
  res.dir   = pefReflDir;
  res.val   = reflColor;
  res.pdf   = 1.0f;
  res.flags = RAY_EVENT_S;
  return res;
}

vec3 MaterialEvalWhitted(uint a_materialId, vec3 l, vec3 v, vec3 n, vec2 tc) {
  const uint   texId     = m_materials[a_materialId].texid[0];
  const vec2 texCoordT = mulRows2x4(m_materials[a_materialId].row0[0], m_materials[a_materialId].row1[0], tc);
  const vec3 texColor = (texture(m_textures[texId], texCoordT)).xyz;
  const vec3 color = m_materials[a_materialId].colors[GLTF_COLOR_BASE].xyz*texColor;
  return lambertEvalBSDF(l, v, n)*color;
}

vec4 LightIntensity(uint a_lightId, vec4 a_wavelengths, vec3 a_rayPos, vec3 a_rayDir) {
  vec4 lightColor = m_lights[a_lightId].intensity;  
  
  // get spectral data for light source
  //
  const uint specId = m_lights[a_lightId].specId;
  if(KSPEC_SPECTRAL_RENDERING !=0 && ubo.m_spectral_mode != 0 && specId < 0xFFFFFFFF)
  {
    const uvec2 data = m_spec_offset_sz[specId];
    const uint offset = data.x;
    const uint size   = data.y;
    lightColor = SampleUniformSpectrum_m_spec_values(offset, a_wavelengths, size);
  }
  lightColor *= m_lights[a_lightId].mult;
  
  // get ies data for light source
  //
  const uint iesId = m_lights[a_lightId].iesId;
  if(KSPEC_LIGHT_IES != 0 && iesId != uint(-1))
  {
    if((m_lights[a_lightId].flags & LIGHT_FLAG_POINT_AREA) != 0)
      a_rayDir = normalize(m_lights[a_lightId].pos.xyz - a_rayPos);
    const vec3 dirTrans = (m_lights[a_lightId].iesMatrix*vec4(a_rayDir, 0.0f)).xyz;
    float sintheta        = 0.0f;
    const vec2 texCoord = sphereMapTo2DTexCoord((-1.0f)*dirTrans, sintheta);
    const vec4 texColor = texture(m_textures[iesId], texCoord);
    lightColor *= texColor;
  }

  // get environment color
  //
  const uint texId = m_lights[a_lightId].texId;

  if(m_lights[a_lightId].distType == LIGHT_DIST_SPOT) // areaSpotLightAttenuation
  {
    float cos1      = m_lights[a_lightId].lightCos1;
    float cos2      = m_lights[a_lightId].lightCos2;
    vec3 norm = m_lights[a_lightId].norm.xyz;
    float cos_theta = max(-dot(a_rayDir, norm), 0.0f);
    lightColor *= mylocalsmoothstep(cos2, cos1, cos_theta);

    if(KSPEC_LIGHT_PROJECTIVE != 0 && (m_lights[a_lightId].flags & LIGHT_FLAG_PROJECTIVE) != 0 && texId != uint(-1))
    {
      const mat4 mat = m_lights[a_lightId].iesMatrix;
      const vec4 posLightClipSpace = mat*vec4(a_rayPos, 1.0f); // 
      const vec3 posLightSpaceNDC = posLightClipSpace.xyz/posLightClipSpace.w;                         // perspective division
      const vec2 shadowTexCoord = vec2(posLightSpaceNDC.x,posLightSpaceNDC.y)*0.5f + vec2(0.5f,0.5f); // just shift coords from [-1,1] to [0,1]  
      const vec4 texColor = texture(m_textures[texId], shadowTexCoord);
      lightColor *= texColor;
    }
  }
  else if(KSPEC_LIGHT_ENV != 0 && texId != uint(-1))
  {
    float sintheta = 0.0f;
    const vec2 texCoord = sphereMapTo2DTexCoord(a_rayDir, sintheta);
    const vec2 texCoordT = mulRows2x4(m_lights[a_lightId].samplerRow0, m_lights[a_lightId].samplerRow1, texCoord);
    const vec4 texColor = texture(m_textures[texId], texCoordT);
    lightColor *= texColor;
  }

  return lightColor;
}

vec3 SpectralCamRespoceToRGB(vec4 specSamples, vec4 waves, uint rayFlags) {
  vec3 rgb = specSamples.xyz;

  if(ubo.m_camResponseSpectrumId[0] < 0)
  {
    const vec3 xyz = SpectrumToXYZ_m_cie_x_m_cie_y_m_cie_z(specSamples, waves, LAMBDA_MIN, LAMBDA_MAX, 0, 0, 0, terminateWavelngths(rayFlags));
    rgb = XYZToRGB(xyz);
  }
  else
  {
    vec4 responceX,  responceY,  responceZ;
    {
      int specId = ubo.m_camResponseSpectrumId[0];
      if(specId >= 0)
      {
        const uvec2 data = m_spec_offset_sz[specId];
        const uint offset = data.x;
        const uint size   = data.y;
        responceX = SampleUniformSpectrum_m_spec_values(offset, waves, size);
      }
      else
        responceX = vec4(1,1,1,1);
      specId = ubo.m_camResponseSpectrumId[1];
      if(specId >= 0)
      {
        const uvec2 data = m_spec_offset_sz[specId];
        const uint offset = data.x;
        const uint size   = data.y;
        responceY = SampleUniformSpectrum_m_spec_values(offset, waves, size);
      }
      else
        responceY = responceX;
      specId = ubo.m_camResponseSpectrumId[2];
      if(specId >= 0)
      {
        const uvec2 data = m_spec_offset_sz[specId];
        const uint offset = data.x;
        const uint size   = data.y;
        responceZ = SampleUniformSpectrum_m_spec_values(offset, waves, size);
      }
      else
        responceZ = responceY;
    }
    vec3 xyz = vec3(0,0,0);
    for (uint i = 0; i < SPECTRUM_SAMPLE_SZ; ++i) {
      xyz.x += specSamples[int(i)]*responceX[int(i)];
      xyz.y += specSamples[int(i)]*responceY[int(i)];
      xyz.z += specSamples[int(i)]*responceZ[int(i)]; 
    } 
    if(ubo.m_camResponseType == CAM_RESPONCE_XYZ)
      rgb = XYZToRGB(xyz);
    else
      rgb = xyz;
  }
  
  return rgb;
}

uint RandomGenId(uint tid) { return tid; }

uint packMatId(uint a_flags, uint a_matId) { return (a_flags & 0xFF000000) | (a_matId & 0x00FFFFFF); }

void RecordLightRndIfNeeded(uint bounceId, int lightId, vec2 rands) {}

LightSample LightSampleRev(int a_lightId, vec3 rands, vec3 illiminationPoint) {
  const uint   gtype  = m_lights[a_lightId].geomType;
  const vec2 rands2 = vec2(rands.x,rands.y);
  switch(gtype)
  {
    case LIGHT_GEOM_DIRECT: return directLightSampleRev_m_lights(a_lightId, rands2, illiminationPoint);
    case LIGHT_GEOM_SPHERE: return sphereLightSampleRev_m_lights(a_lightId, rands2);
    case LIGHT_GEOM_POINT:  return pointLightSampleRev_m_lights(a_lightId);
    case LIGHT_GEOM_ENV: 
    if(KSPEC_LIGHT_ENV != 0)
    {
      const uint offset = m_lights[a_lightId].pdfTableOffset;
      const uint sizeX = m_lights[a_lightId].pdfTableSizeX;
      const uint sizeY = m_lights[a_lightId].pdfTableSizeY;
      
      const Map2DPiecewiseSample sam = SampleMap2D(rands, offset, int(sizeX), int(sizeY));

      // apply inverse texcoord transform to get phi and theta (SKY_DOME_INV_MATRIX0 in HydraCore2)
      //
      const vec2 texCoordT = mulRows2x4(m_lights[a_lightId].samplerRow0Inv, m_lights[a_lightId].samplerRow1Inv, sam.texCoord);

      float sintheta = 0.0f;
      const vec3 sampleDir = texCoord2DToSphereMap(texCoordT, sintheta);
      const vec3 samplePos = illiminationPoint + sampleDir*1000.0f; // TODO: add sceen bounding sphere radius here
      const float  samplePdf = (sam.mapPdf * 1.0f) / (2.f * M_PI * M_PI * max(abs(sintheta), 1e-20f)); // TODO: pass computed pdf to 'LightEvalPDF'
      
      LightSample res;
      res.hasIES = false;
      res.isOmni = true;
      res.norm   = sampleDir; 
      res.pos    = samplePos;
      res.pdf    = samplePdf; // evaluated here for environment lights 
      return res;
    }
    default:                return areaLightSampleRev_m_lights(a_lightId, rands2);
  };
}

EyeRayData SampleCameraRay(inout RandomGen pGen, uint tid) {
  const uint XY = m_packedXY[tid];
  const uint x  = (XY & 0x0000FFFF);
  const uint y  = (XY & 0xFFFF0000) >> 16;

  if(x == 256 && y == 256)
  {
    int a = 2;
  }

  const vec4 pixelOffsets = GetRandomNumbersLens(tid, pGen);

  const float xCoordNormalized = (float(x) + pixelOffsets.x)/float(ubo.m_winWidth);
  const float yCoordNormalized = (float(y) + pixelOffsets.y)/float(ubo.m_winHeight);

  vec3 rayDir = EyeRayDirNormalized(xCoordNormalized, yCoordNormalized, ubo.m_projInv);
  vec3 rayPos = vec3(0,0,0);
  
  if (ubo.m_camLensRadius > 0.0f)
  {
    const float tFocus         = ubo.m_camTargetDist / (-rayDir.z);
    const vec3 focusPosition = rayPos + rayDir*tFocus;
    const vec2 xy = ubo.m_camLensRadius*2.0f*MapSamplesToDisc(vec2(pixelOffsets.z - 0.5f,pixelOffsets.w - 0.5f));
    rayPos.x += xy.x;
    rayPos.y += xy.y;
    rayDir = normalize(focusPosition - rayPos);
  }
  else if(KSPEC_OPTIC_SIM !=0 && ubo.m_enableOpticSim != 0) // not nessesary part of QMC. Just implemented here for test cases, could be moved in main class further  
  {
    const vec2 xy = 0.25f*ubo.m_physSize*vec2(2.0f*xCoordNormalized - 1.0f,2.0f*yCoordNormalized - 1.0f);
    
    rayPos = vec3(xy.x,xy.y,0);
    
    const vec2 rareSam = LensRearRadius()*2.0f*MapSamplesToDisc(vec2(pixelOffsets.z - 0.5f,pixelOffsets.w - 0.5f));
    const vec3 shootTo = vec3(rareSam.x,rareSam.y,LensRearZ());
    const vec3 ray_dirF = normalize(shootTo - rayPos);
    
    float cosTheta = abs(ray_dirF.z);
    rayDir         = ray_dirF;
    bool success = TraceLensesFromFilm(rayPos, rayDir);
    
    if (!success) 
    {
      rayPos = vec3(0,-10000000.0,0.0); // shoot ray under the floor
      rayDir = vec3(0,-1,0);
    }
    else
    {
      rayDir = vec3(-1,-1,-1)*normalize(rayDir);
      rayPos = vec3(-1,-1,-1)*rayPos;
    }
  }

  EyeRayData res;
  {
    res.rayPos = rayPos;
    res.rayDir = rayDir;
    res.x      = x;
    res.y      = y;
    res.timeSam = 0.0f;
    res.waveSam = 1.0f;
    if(ubo.m_normMatrices2_size != 0)
      res.timeSam = GetRandomNumbersTime(tid, pGen);
    if(KSPEC_SPECTRAL_RENDERING !=0 && ubo.m_spectral_mode != 0)
      res.waveSam = GetRandomNumbersSpec(tid, pGen);
    res.cosTheta = 1.0f;
  }
  
  RecordPixelRndIfNeeded(vec2(pixelOffsets.x,pixelOffsets.y), res.waveSam);

  return res;
}

void RecordRayHitIfNeeded(uint bounceId, CRT_Hit hit) {}

vec4 GetRandomNumbersLgts(uint tid, inout RandomGen a_gen, int a_bounce) {
  const float  rndId = rndFloat1_Pseudo(a_gen); // don't use single rndFloat4 (!!!)
  const vec4 rands = rndFloat4_Pseudo(a_gen); // don't use single rndFloat4 (!!!)
  return vec4(rands.x,rands.y,rands.z,rndId);
}

uint RemapMaterialId(uint a_mId, int a_instId) {
  const int remapListId  = m_remapInst[a_instId];
  if(remapListId == -1)
    return a_mId;

  const int r_offset     = m_allRemapListsOffsets[remapListId];
  const int r_size       = m_allRemapListsOffsets[remapListId+1] - r_offset;
  const ivec2 offsAndSize = ivec2(r_offset,r_size);
  
  uint res = a_mId;
  
  // for (int i = 0; i < offsAndSize.y; i++) // linear search version
  // {
  //   int idRemapFrom = m_allRemapLists[offsAndSize.x + i * 2 + 0];
  //   int idRemapTo   = m_allRemapLists[offsAndSize.x + i * 2 + 1];
  //   if (idRemapFrom == a_mId) {
  //     res = idRemapTo;
  //     break;
  //   }
  // }

  int low  = 0;
  int high = offsAndSize.y - 1;              // binary search version
  
  while (low <= high)
  {
    const int mid         = low + ((high - low) / 2);
    const int idRemapFrom = m_allRemapLists[offsAndSize.x + mid * 2 + 0];
    if (uint(idRemapFrom) >= a_mId)
      high = mid - 1;
    else //if(a[mid]<i)
      low = mid + 1;
  }

  if (high+1 < offsAndSize.y)
  {
    const int idRemapFrom = m_allRemapLists[offsAndSize.x + (high + 1) * 2 + 0];
    const int idRemapTo   = m_allRemapLists[offsAndSize.x + (high + 1) * 2 + 1];
    res                   = (uint(idRemapFrom) == a_mId) ? uint(idRemapTo) : a_mId;
  }

  return res;
}

BsdfEval MaterialEval(uint a_materialId, vec4 wavelengths, vec3 l, vec3 v, vec3 n, vec3 tan, vec2 tc) {
  BsdfEval res;
  {
    res.val = vec4(0,0,0,0);
    res.pdf   = 0.0f;
  }

  MatIdWeight currMat = make_id_weight(a_materialId, 1.0f);
  MatIdWeight material_stack[KSPEC_BLEND_STACK_SIZE];
  if(KSPEC_MAT_TYPE_BLEND != 0)
    material_stack[0] = currMat;
  int top = 0;
  bool needPop = false;

  do
  {
    if(KSPEC_MAT_TYPE_BLEND != 0)
    {
      if(needPop)
      {
        top--;
        currMat = material_stack[max(top, 0)];
      }
      else
        needPop = true; // if not blend, pop on next iter
    } 
    
    // BSDF is multiplied (outside) by old cosThetaOut.
    // When normal map is enables this becames wrong because normal is changed;
    // First : return cosThetaOut in sam;
    // Second: apply cos(theta2)/cos(theta1) to cos(theta1) to get cos(theta2)
    //
    const vec3 geomNormal = n;
          vec3 shadeNormal = n;
    float bumpCosMult = 1.0f; 
    const uint normalMapId = m_materials[currMat.id].texid[1];
    if(KSPEC_BUMP_MAPPING != 0 && normalMapId != 0xFFFFFFFF) 
    {
      shadeNormal = BumpMapping(normalMapId, currMat.id, geomNormal, tan, tc);
      const vec3 lDir = l;     
      const float  clampVal = 1e-6f;  
      const float cosThetaOut1 = max(dot(lDir, geomNormal), 0.0f);
      const float cosThetaOut2 = max(dot(lDir, shadeNormal), 0.0f);
      bumpCosMult              = cosThetaOut2 / max(cosThetaOut1, clampVal);
      if (cosThetaOut1 <= 0.0f)
        bumpCosMult = 0.0f;
    }

    const vec2 texCoordT = mulRows2x4(m_materials[currMat.id].row0[0], m_materials[currMat.id].row1[0], tc);
    const uint   texId     = m_materials[currMat.id].texid[0];
    const vec4 texColor = texture(m_textures[texId], texCoordT);
    const uint   mtype     = m_materials[currMat.id].mtype;
    const uint   cflags    = m_materials[currMat.id].cflags;

    vec4 fourScalarMatParams = vec4(1,1,1,1);
    if(KSPEC_MAT_FOUR_TEXTURES != 0 && (cflags & FLAG_FOUR_TEXTURES) != 0)
    {
      const uint texId2  = m_materials[currMat.id].texid[2];
      const uint texId3  = m_materials[currMat.id].texid[3];

      const vec2 texCoord2T = mulRows2x4(m_materials[currMat.id].row0[2], m_materials[currMat.id].row1[2], tc);
      const vec2 texCoord3T = mulRows2x4(m_materials[currMat.id].row0[3], m_materials[currMat.id].row1[3], tc);

      const vec4 color2 = texture(m_textures[texId2], texCoord2T);
      const vec4 color3 = texture(m_textures[texId3], texCoord3T);
    
      if((cflags & FLAG_PACK_FOUR_PARAMS_IN_TEXTURE) != 0)
        fourScalarMatParams = color2;
      else
        fourScalarMatParams = vec4(color2.x,color3.x,1,1);
    }

    BsdfEval currVal;
    {
      currVal.val = vec4(0,0,0,0);
      currVal.pdf   = 0.0f;
    }
    switch(mtype)
    {
      case MAT_TYPE_GLTF:
      if(KSPEC_MAT_TYPE_GLTF != 0)
      {
        const vec4 color = (m_materials[currMat.id].colors[GLTF_COLOR_BASE]) * texColor;
        gltfEval_m_materials(currMat.id, l, v, shadeNormal, tc, color, fourScalarMatParams, currVal);
        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
      }
      break;
      case MAT_TYPE_GLASS:
      if(KSPEC_MAT_TYPE_GLASS != 0)
      {
        glassEval_m_materials(currMat.id, l, v, geomNormal, tc, vec3(0,0,0), currVal);
        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
      }
      break;
      case MAT_TYPE_CONDUCTOR: 
      if(KSPEC_MAT_TYPE_CONDUCTOR != 0)
      {
        const vec3 alphaTex = texColor.xyz;
        const vec2 alpha = vec2(m_materials[currMat.id].data[CONDUCTOR_ROUGH_V],m_materials[currMat.id].data[CONDUCTOR_ROUGH_U]);

        if(!trEffectivelySmooth(alpha))
        {
          const vec4 etaSpec = SampleMatParamSpectrum(currMat.id, wavelengths, CONDUCTOR_ETA, 0);
          const vec4 kSpec = SampleMatParamSpectrum(currMat.id, wavelengths, CONDUCTOR_K,   1);
          conductorRoughEval_m_materials(currMat.id, etaSpec, kSpec, l, v, shadeNormal, tc, alphaTex, currVal);
        }

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
      }
      break;
      case MAT_TYPE_THIN_FILM: 
      if(KSPEC_MAT_TYPE_THIN_FILM != 0)
      {
        const vec3 alphaTex = texColor.xyz;  
        const vec2 alpha = vec2(m_materials[currMat.id].data[FILM_ROUGH_V],m_materials[currMat.id].data[FILM_ROUGH_U]);

        if(!trEffectivelySmooth(alpha))
        {
          uint t_offset = floatBitsToUint(m_materials[currMat.id].data[FILM_THICKNESS_OFFSET]);
          uint layers = floatBitsToUint(m_materials[currMat.id].data[FILM_LAYERS_COUNT]);
          //complex a_ior[KSPEC_FILMS_STACK_SIZE];
          // IORVector a_ior;
          a_ior[0] = to_complex(m_materials[currMat.id].data[FILM_ETA_EXT]);
          for (uint layer = 0; layer < layers; layer++)
          {
            a_ior[layer + 1] = make_complex(SampleFilmsSpectrum(currMat.id, wavelengths, FILM_ETA_OFFSET, FILM_ETA_SPECID_OFFSET, layer)[0],SampleFilmsSpectrum(currMat.id, wavelengths, FILM_K_OFFSET, FILM_K_SPECID_OFFSET, layer)[0]);
          }

          const uint precomp_id = floatBitsToUint(m_materials[currMat.id].data[FILM_PRECOMP_ID]);

          filmRoughEval_m_materials_m_films_thickness_vec_m_precomp_thin_films(currMat.id, t_offset, layers, wavelengths, l, v, n, tc, alphaTex, currVal, precomp_id * FILM_ANGLE_RES * FILM_LENGTH_RES * 4);
        }

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
      }
      break;
      case MAT_TYPE_DIFFUSE:
      if(KSPEC_MAT_TYPE_DIFFUSE != 0)
      {
        const vec4 color = texColor;
        vec4 reflSpec = SampleMatColorSpectrumTexture(currMat.id, wavelengths, DIFFUSE_COLOR, 0, tc);
        if(ubo.m_spectral_mode == 0)
          reflSpec *= color;        
        diffuseEval_m_materials(currMat.id, reflSpec, l, v, shadeNormal, tc, currVal);

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
      }
      break;
      case MAT_TYPE_PLASTIC:
      if(KSPEC_MAT_TYPE_PLASTIC != 0)
      {
        const vec4 color = texColor;
        vec4 reflSpec = SampleMatColorSpectrumTexture(currMat.id, wavelengths, PLASTIC_COLOR, 0, tc);
        // float4 reflSpec    = SampleMatColorParamSpectrum(currMat.id, wavelengths, PLASTIC_COLOR, 0);
        if(ubo.m_spectral_mode == 0)
          reflSpec *= color;
        const uint precomp_id = m_materials[currMat.id].datai[0];
        plasticEval_m_materials_m_precomp_coat_transmittance(currMat.id, reflSpec, l, v, shadeNormal, tc, currVal, precomp_id * MI_ROUGH_TRANSMITTANCE_RES);

        res.val += currVal.val * currMat.weight * bumpCosMult;
        res.pdf += currVal.pdf * currMat.weight;
      }
      break;
      case MAT_TYPE_DIELECTRIC:
      if(KSPEC_MAT_TYPE_DIELECTRIC != 0)
      {
        dielectricSmoothEval(res); // val and pdf are always zero
      }
      break;
      case MAT_TYPE_BLEND:
      if(KSPEC_MAT_TYPE_BLEND != 0)
      {
        MatIdWeightPair childMats = BlendEval(currMat, wavelengths, l, v, geomNormal, tc);
        currMat = childMats.first;
        needPop = false;                        // we already put 'childMats.first' in 'currMat'
        if(top + 1 <= KSPEC_BLEND_STACK_SIZE)
        {
          material_stack[top] = childMats.second; // remember second mat in stack
          top++;
        }
      }
      break;
      default:
        break;
    }

  } while(KSPEC_MAT_TYPE_BLEND != 0 && top > 0);

  return res;
}

bool isDeadRay(uint a_flags) { return (a_flags & RAY_FLAG_IS_DEAD)        != 0; }

bool hasNonSpecular(uint a_flags) { return (a_flags & RAY_FLAG_HAS_NON_SPEC)   != 0; }

uint extractMatId(uint a_flags) { return (a_flags & 0x00FFFFFF); }

void RecordShadowHitIfNeeded(uint bounceId, bool inShadow) {}

float LightEvalPDF(int a_lightId, vec3 illuminationPoint, vec3 ray_dir, const vec3 lpos, const vec3 lnorm, float a_envPdf) {
  const uint gtype = m_lights[a_lightId].geomType;
  if(gtype == LIGHT_GEOM_ENV)
    return a_envPdf;

  const float hitDist   = length(illuminationPoint - lpos);
  const float cosValTmp = dot(ray_dir, -1.0f*lnorm);
  float cosVal = 1.0f;
  switch(gtype)
  {
    case LIGHT_GEOM_SPHERE:
    {
      // const float  lradius = m_lights[a_lightId].size.x;
      // const float3 lcenter = to_float3(m_lights[a_lightId].pos);
      //if (DistanceSquared(illuminationPoint, lcenter) - lradius*lradius <= 0.0f)
      //  return 1.0f;
      const vec3 dirToV = normalize(lpos - illuminationPoint);
      cosVal = abs(dot(dirToV, lnorm));
    }
    break;

    case LIGHT_GEOM_POINT:
    {
      if(m_lights[a_lightId].distType == LIGHT_DIST_LAMBERT)
        cosVal = max(cosValTmp, 0.0f);
    };
    break;

    default: // any type of area light
    //cosVal = std::max(cosValTmp, 0.0f);                                                               ///< Note(!): actual correct way for area lights
    cosVal = (m_lights[a_lightId].iesId == uint(-1)) ? max(cosValTmp, 0.0f) : abs(cosValTmp); ///< Note(!): this is not physically correct for area lights, see test_206;
    break;                                                                                              ///< Note(!): dark line on top of image for pink light appears because area light don't shine to the side. 
  };
  
  return PdfAtoW(m_lights[a_lightId].pdfA, hitDist, cosVal);
}

BsdfSample MaterialSampleAndEval(uint a_materialId, uint tid, uint bounce, vec4 wavelengths, inout RandomGen a_gen, vec3 v, vec3 n, vec3 tan, vec2 tc, inout MisData a_misPrev, const uint a_currRayFlags) {
  BsdfSample res;
  {
    res.val   = vec4(0,0,0,0);
    res.pdf   = 1.0f;
    res.dir   = vec3(0,1,0);
    res.ior   = 1.0f;
    res.flags = a_currRayFlags;
    res.ior   = 1.0f;
  }

  uint currMatId = a_materialId;
  uint     mtype     = m_materials[currMatId].mtype;
  uint     layer     = 0;
  while(KSPEC_MAT_TYPE_BLEND != 0 && mtype == MAT_TYPE_BLEND)
  {
    currMatId = BlendSampleAndEval(currMatId, tid, bounce, layer, wavelengths, a_gen, v, n, tc, a_misPrev, res);
    mtype     = m_materials[currMatId].mtype;
    layer++;
  }
  
  // BSDF is multiplied (outside) by cosThetaOut1.
  // When normal map is enables this becames wrong because normal is changed;
  // First : return cosThetaOut in sam;
  // Second: apply cos(theta2)/cos(theta1) to cos(theta1) to get cos(theta2)
  //
  const uint normalMapId   = m_materials[currMatId].texid[1];
  const vec3 geomNormal = n;
        vec3 shadeNormal = n;

  if(KSPEC_BUMP_MAPPING != 0 && normalMapId != 0xFFFFFFFF)
    shadeNormal = BumpMapping(normalMapId, currMatId, geomNormal, tan, tc);

  const vec2 texCoordT = mulRows2x4(m_materials[currMatId].row0[0], m_materials[currMatId].row1[0], tc);
  const uint   texId     = m_materials[currMatId].texid[0];
  const vec4 texColor = texture(m_textures[texId], texCoordT);
  const vec4 rands = GetRandomNumbersMats(tid, a_gen, int(bounce));
  const uint cflags      = m_materials[currMatId].cflags;
  RecordMatRndNeeded(bounce, rands);

  vec4 fourScalarMatParams = vec4(1,1,1,1);
  if(KSPEC_MAT_FOUR_TEXTURES != 0 && (cflags & FLAG_FOUR_TEXTURES) != 0)
  {
    const uint texId2  = m_materials[currMatId].texid[2];
    const uint texId3  = m_materials[currMatId].texid[3];
    
    const vec2 texCoord2T = mulRows2x4(m_materials[currMatId].row0[2], m_materials[currMatId].row1[2], tc);
    const vec2 texCoord3T = mulRows2x4(m_materials[currMatId].row0[3], m_materials[currMatId].row1[3], tc);

    const vec4 color2 = texture(m_textures[texId2], texCoord2T);
    const vec4 color3 = texture(m_textures[texId3], texCoord3T);
    
    if((cflags & FLAG_PACK_FOUR_PARAMS_IN_TEXTURE) != 0)
      fourScalarMatParams = color2;
    else
      fourScalarMatParams = vec4(color2.x,color3.x,1,1);
  }

  switch(mtype)
  {
    case MAT_TYPE_GLTF:
    if(KSPEC_MAT_TYPE_GLTF != 0)
    {
      const vec4 color = m_materials[currMatId].colors[GLTF_COLOR_BASE]*texColor;
      gltfSampleAndEval_m_materials(currMatId, rands, v, shadeNormal, tc, color, fourScalarMatParams, res);
    }
    break;
    case MAT_TYPE_GLASS: 
    if(KSPEC_MAT_TYPE_GLASS != 0)
    {
      glassSampleAndEval_m_materials(currMatId, rands, v, geomNormal, tc, res, a_misPrev);
    }
    break;
    case MAT_TYPE_CONDUCTOR:
    if(KSPEC_MAT_TYPE_CONDUCTOR != 0)
    {
      const vec3 alphaTex = texColor.xyz;    
      const vec2 alpha = vec2(m_materials[currMatId].data[CONDUCTOR_ROUGH_V],m_materials[currMatId].data[CONDUCTOR_ROUGH_U]);
      const vec4 etaSpec = SampleMatParamSpectrum(currMatId, wavelengths, CONDUCTOR_ETA, 0);
      const vec4 kSpec = SampleMatParamSpectrum(currMatId, wavelengths, CONDUCTOR_K,   1);
      if(trEffectivelySmooth(alpha))
        conductorSmoothSampleAndEval_m_materials(currMatId, etaSpec, kSpec, rands, v, shadeNormal, tc, res);
      else
        conductorRoughSampleAndEval_m_materials(currMatId, etaSpec, kSpec, rands, v, shadeNormal, tc, alphaTex, res);
    }
    break;
    case MAT_TYPE_THIN_FILM:
    if(KSPEC_MAT_TYPE_THIN_FILM != 0)
    {
      const vec3 alphaTex = texColor.xyz;  
      const vec2 alpha = vec2(m_materials[currMatId].data[FILM_ROUGH_V],m_materials[currMatId].data[FILM_ROUGH_U]);

      uint t_offset = floatBitsToUint(m_materials[currMatId].data[FILM_THICKNESS_OFFSET]);
      uint layers = floatBitsToUint(m_materials[currMatId].data[FILM_LAYERS_COUNT]);

      //complex a_ior[KSPEC_FILMS_STACK_SIZE];
      // IORVector a_ior;
      a_ior[0] = to_complex(m_materials[currMatId].data[FILM_ETA_EXT]);
      for (uint layer = 0; layer < layers; layer++)
      {
        a_ior[layer + 1] = make_complex(SampleFilmsSpectrum(currMatId, wavelengths, FILM_ETA_OFFSET, FILM_ETA_SPECID_OFFSET, layer)[0],SampleFilmsSpectrum(currMatId, wavelengths, FILM_K_OFFSET, FILM_K_SPECID_OFFSET, layer)[0]);
      }

      const uint precomp_id = floatBitsToUint(m_materials[currMatId].data[FILM_PRECOMP_ID]);

      if(trEffectivelySmooth(alpha))
        filmSmoothSampleAndEval_m_materials_m_films_thickness_vec_m_precomp_thin_films(currMatId, t_offset, layers, wavelengths, a_misPrev.ior, rands, v, n, tc, res, precomp_id * FILM_ANGLE_RES * FILM_LENGTH_RES * 4);
      else
        filmRoughSampleAndEval_m_materials_m_films_thickness_vec_m_precomp_thin_films(currMatId, t_offset, layers, wavelengths, a_misPrev.ior, rands, v, n, tc, alphaTex, res, precomp_id * FILM_ANGLE_RES * FILM_LENGTH_RES * 4);

      //res.flags |= (specId < 0xFFFFFFFF) ? RAY_FLAG_WAVES_DIVERGED : 0;
      res.flags |= RAY_FLAG_WAVES_DIVERGED;

      a_misPrev.ior = res.ior;
    }
    break;
    case MAT_TYPE_DIFFUSE:
    if(KSPEC_MAT_TYPE_DIFFUSE != 0)
    {
      const vec4 color = texColor;
      vec4 reflSpec = SampleMatColorSpectrumTexture(currMatId, wavelengths, DIFFUSE_COLOR, 0, tc);
      if(ubo.m_spectral_mode == 0)
        reflSpec *= color;
      
      diffuseSampleAndEval_m_materials(currMatId, reflSpec, rands, v, shadeNormal, tc, res);
    }
    break;
    case MAT_TYPE_PLASTIC:
    if(KSPEC_MAT_TYPE_PLASTIC != 0)
    {
      const vec4 color = texColor;
      vec4 reflSpec = SampleMatColorSpectrumTexture(currMatId, wavelengths, PLASTIC_COLOR, 0, tc);
      // float4 reflSpec    = SampleMatColorParamSpectrum(currMatId, wavelengths, PLASTIC_COLOR, 0);
      if(ubo.m_spectral_mode == 0)
        reflSpec *= color;

      const uint precomp_id = m_materials[currMatId].datai[0];

      plasticSampleAndEval_m_materials_m_precomp_coat_transmittance(currMatId, reflSpec, rands, v, shadeNormal, tc, res, precomp_id * MI_ROUGH_TRANSMITTANCE_RES);
    }
    break;
    case MAT_TYPE_DIELECTRIC:
    if(KSPEC_MAT_TYPE_DIELECTRIC != 0)
    {
      const vec4 intIORSpec = SampleMatParamSpectrum(currMatId, wavelengths, DIELECTRIC_ETA_INT, 0);
      const uint specId = m_materials[currMatId].spdid[0];
      dielectricSmoothSampleAndEval_m_materials(currMatId, intIORSpec, a_misPrev.ior, rands, v, shadeNormal, tc, res);

      res.flags |= (specId < 0xFFFFFFFF) ? RAY_FLAG_WAVES_DIVERGED : 0;

      a_misPrev.ior = res.ior;
    }
    break;
    default:
    break;
  }
  
  // BSDF is multiplied (outside) by cosThetaOut1.
  // When normal map is enables this becames wrong because normal is changed;
  // First : return cosThetaOut in sam;
  // Second: apply cos(theta2)/cos(theta1) to cos(theta1) to get cos(theta2)
  //
  if(KSPEC_BUMP_MAPPING != 0 && normalMapId != 0xFFFFFFFF)
  {
    const float cosThetaOut1 = abs(dot(res.dir, geomNormal));
    const float cosThetaOut2 = abs(dot(res.dir, shadeNormal));
    res.val *= cosThetaOut2 / max(cosThetaOut1, 1e-10f);
  }

  return res;
}

// RayScene intersection with 'm_pAccelStruct'
//
CRT_Hit m_pAccelStruct_RayQuery_NearestHit(const vec4 rayPos, const vec4 rayDir)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsOpaqueEXT, 0xff, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);
  
  while(rayQueryProceedEXT(rayQuery)) { } // actually may omit 'while' when 'gl_RayFlagsOpaqueEXT' is used
 
  CRT_Hit res;
  res.primId = -1;
  res.instId = -1;
  res.geomId = -1;
  res.t      = rayDir.w;

  if(rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT)
  {    
	  res.primId    = rayQueryGetIntersectionPrimitiveIndexEXT(rayQuery, true);
	  res.geomId    = rayQueryGetIntersectionInstanceCustomIndexEXT(rayQuery, true);
    res.instId    = rayQueryGetIntersectionInstanceIdEXT    (rayQuery, true);
	  res.t         = rayQueryGetIntersectionTEXT(rayQuery, true);
    vec2 bars     = rayQueryGetIntersectionBarycentricsEXT(rayQuery, true);
    
    res.coords[0] = bars.y;
    res.coords[1] = bars.x;
    res.coords[2] = 1.0f - bars.y - bars.x;
    res.coords[3] = 0.0f;
  }

  return res;
}

CRT_Hit m_pAccelStruct_RayQuery_NearestHitMotion(const vec4 rayPos, const vec4 rayDir, float t) { return m_pAccelStruct_RayQuery_NearestHit(rayPos, rayDir); }

bool m_pAccelStruct_RayQuery_AnyHit(const vec4 rayPos, const vec4 rayDir)
{
  rayQueryEXT rayQuery;
  rayQueryInitializeEXT(rayQuery, m_pAccelStruct, gl_RayFlagsTerminateOnFirstHitEXT, 0xff, rayPos.xyz, rayPos.w, rayDir.xyz, rayDir.w);
  rayQueryProceedEXT(rayQuery);
  return (rayQueryGetIntersectionTypeEXT(rayQuery, true) == gl_RayQueryCommittedIntersectionTriangleEXT);
}

bool m_pAccelStruct_RayQuery_AnyHitMotion(const vec4 rayPos, const vec4 rayDir, float t) { return m_pAccelStruct_RayQuery_AnyHit(rayPos, rayDir); }

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
layout( push_constant ) uniform kernelArgs
{
  uint channels;
  uint iNumElementsX; 
  uint iNumElementsY; 
  uint iNumElementsZ; 
  uint tFlagsMask;    
} kgenArgs;

///////////////////////////////////////////////////////////////// subkernels here
void kernel_ContributeToImage_m_packedXY_out_color(uint tid, in uint rayFlags, uint channels, in vec4 a_accumColor, in RandomGen gen, uint in_pakedXYOffset, in vec4 wavelengths, uint out_colorOffset) 
{
  
  
  if(tid >= ubo.m_maxThreadId) // don't contrubute to image in any "record" mode
    return;
  
  m_randomGens[RandomGenId(tid)] = gen;
  if(ubo.m_disableImageContrib !=0)
    return;

  const uint XY = m_packedXY[tid + in_pakedXYOffset];
  const uint x  = (XY & 0x0000FFFF);
  const uint y  = (XY & 0xFFFF0000) >> 16;
  
  vec4 specSamples = a_accumColor; 
  vec4 tmpVal = specSamples*ubo.m_camRespoceRGB;
  vec3 rgb = tmpVal.xyz;

  if(KSPEC_SPECTRAL_RENDERING!=0 && ubo.m_spectral_mode != 0) 
  {
    const vec4 waves = wavelengths;
    const uint rayFlags2 = rayFlags; 
    rgb = SpectralCamRespoceToRGB(specSamples, waves, rayFlags2);
  }

  vec4 colorRes = ubo.m_exposureMult * vec4(rgb, 1.0f);
  
  if(channels == 1) // monochromatic spectral
  {
    // const float mono = 0.2126f*colorRes.x + 0.7152f*colorRes.y + 0.0722f*colorRes.z;
    out_color[y * uint(ubo.m_winWidth) + x + out_colorOffset] += specSamples.x * ubo.m_exposureMult;
  } 
  else if(channels <= 4) 
  {
    out_color[(y*uint(ubo.m_winWidth)+x)*channels + 0 + out_colorOffset] += colorRes.x;
    out_color[(y*uint(ubo.m_winWidth)+x)*channels + 1 + out_colorOffset] += colorRes.y;
    out_color[(y*uint(ubo.m_winWidth)+x)*channels + 2 + out_colorOffset] += colorRes.z;
  }
  else // always spectral rendering
  {
    vec4 waves = (wavelengths);
    vec4 color = (a_accumColor)*ubo.m_exposureMult;
    for(int i=0;i<4;i++) {
      const float t         = (waves[i] - LAMBDA_MIN)/(LAMBDA_MAX-LAMBDA_MIN);
      const int channelId   = min(int(float(channels)*t), int(channels)-1);
      const int offsetPixel = int(y)*ubo.m_winWidth + int(x);
      const int offsetLayer = channelId*ubo.m_winWidth*ubo.m_winHeight;
      out_color[offsetLayer + offsetPixel + out_colorOffset] += color[i];
    }
  }


}

void kernel_SampleLightSource(uint tid, in vec4 rayPosAndNear, in vec4 rayDirAndFar, in vec4 wavelengths, in vec4 in_hitPart1, in vec4 in_hitPart2, in vec4 in_hitPart3, in uint rayFlags, in float a_time, uint bounce, inout RandomGen a_gen, inout vec4 out_shadeColor) 
{
  
  if(tid >= ubo.m_maxThreadId)
    return;
  const uint currRayFlags = rayFlags;
  if(isDeadRay(currRayFlags))
    return;
    
  const uint matId = extractMatId(currRayFlags);
  const vec3 ray_dir = rayDirAndFar.xyz;
  
  const vec4 data1 = in_hitPart1;
  const vec4 data2 = in_hitPart2;
  const vec4 lambda = wavelengths;

  SurfaceHit hit;
  hit.pos  = data1.xyz;
  hit.norm = data2.xyz;
  hit.tang = in_hitPart3.xyz;
  hit.uv   = vec2(data1.w,data2.w);
  
  const int bounceTmp = int(bounce); 
  const vec4 rands = GetRandomNumbersLgts(tid, a_gen, bounceTmp); 
  const int lightId  = min(int(floor(rands.w * float(ubo.m_lights_size))), int(ubo.m_lights_size - 1u));
  RecordLightRndIfNeeded(bounce, lightId, vec2(rands.x,rands.y)); // TODO: write float3 ?

  if(lightId < 0) // no lights or invalid light id
  {
    out_shadeColor = vec4(0.0f,0.0f,0.0f,0.0f);
    return;
  }
  
  const LightSample lSam = LightSampleRev(lightId, rands.xyz, hit.pos);
  const float  hitDist   = sqrt(dot(hit.pos - lSam.pos, hit.pos - lSam.pos));

  const vec3 shadowRayDir = normalize(lSam.pos - hit.pos); // explicitSam.direction;
  const vec3 shadowRayPos = hit.pos + hit.norm * max(maxcomp(hit.pos), 1.0f)*5e-6f; // TODO: see Ray Tracing Gems, also use flatNormal for offset

  float time = a_time;
  const bool inIllumArea = (dot(shadowRayDir, lSam.norm) < 0.0f) || lSam.isOmni || lSam.hasIES;
  const bool needShade = inIllumArea && !m_pAccelStruct_RayQuery_AnyHitMotion(vec4(shadowRayPos, 0.0f), vec4(shadowRayDir, hitDist*0.9995f), time); /// (!!!) expression-way, RT pipeline bug work around, if change check test_213
  RecordShadowHitIfNeeded(bounce, needShade);

  if(needShade) /// (!!!) expression-way to compute 'needShade', RT pipeline bug work around, if change check test_213
  {
    const BsdfEval bsdfV    = MaterialEval(matId, lambda, shadowRayDir, (-1.0f)*ray_dir, hit.norm, hit.tang, hit.uv);
    float cosThetaOut       = max(dot(shadowRayDir, hit.norm), 0.0f);
    
    float      lgtPdfW      = LightPdfSelectRev(lightId) * LightEvalPDF(lightId, shadowRayPos, shadowRayDir, lSam.pos, lSam.norm, lSam.pdf);
    float      misWeight    = (ubo.m_intergatorType == INTEGRATOR_MIS_PT) ? misWeightHeuristic(lgtPdfW, bsdfV.pdf) : 1.0f;
    const bool isDirect = (m_lights[lightId].geomType == LIGHT_GEOM_DIRECT); 
    const bool isPoint = (m_lights[lightId].geomType == LIGHT_GEOM_POINT); 
    
    if(isDirect)
    {
      misWeight = 1.0f;
      lgtPdfW   = 1.0f;
    }
    else if(isPoint)
      misWeight = 1.0f;

    const bool isDirectLight = !hasNonSpecular(currRayFlags);
    if((ubo.m_renderLayer == FB_DIRECT   && !isDirectLight) || 
       (ubo.m_renderLayer == FB_INDIRECT && isDirectLight)) // skip some number of bounces if this is set
      misWeight = 0.0f;
      
    
    const vec4 lightColor = LightIntensity(uint(lightId), lambda, shadowRayPos, shadowRayDir);
    out_shadeColor = (lightColor * bsdfV.val / lgtPdfW) * cosThetaOut * misWeight;
  }
  else
    out_shadeColor = vec4(0.0f,0.0f,0.0f,0.0f);

}

void kernel_NextBounce(uint tid, uint bounce, in vec4 in_hitPart1, in vec4 in_hitPart2, in vec4 in_hitPart3, in uint in_instId, in vec4 in_shadeColor, inout vec4 rayPosAndNear, inout vec4 rayDirAndFar, in vec4 wavelengths, inout vec4 accumColor, inout vec4 accumThoroughput, inout RandomGen a_gen, inout MisData misPrev, inout uint rayFlags) 
{
  
  if(tid >= ubo.m_maxThreadId)
    return;
  const uint currRayFlags = rayFlags;
  if(isDeadRay(currRayFlags))
    return;
    
  const uint matId = extractMatId(currRayFlags);

  // process surface hit case
  //
  const vec3 ray_dir = rayDirAndFar.xyz;
  const vec3 ray_pos = rayPosAndNear.xyz;
  const vec4 lambda = wavelengths;
  
  const vec4 data1 = in_hitPart1;
  const vec4 data2 = in_hitPart2;
  
  SurfaceHit hit;
  hit.pos  = data1.xyz;
  hit.norm = data2.xyz;
  hit.tang = in_hitPart3.xyz;
  hit.uv   = vec2(data1.w,data2.w);

  const float hitDist = in_hitPart3.w;
  
  const MisData prevBounce = misPrev;
  const float   prevPdfW   = prevBounce.matSamplePdf;

  // process light hit case
  //
  if(m_materials[matId].mtype == MAT_TYPE_LIGHT_SOURCE)
  {
    const uint   texId     = m_materials[matId].texid[0];
    const vec2 texCoordT = mulRows2x4(m_materials[matId].row0[0], m_materials[matId].row1[0], hit.uv);
    const vec4 texColor = texture(m_textures[texId], texCoordT);
    const uint   lightId   = m_instIdToLightInstId[in_instId]; 
    
    const vec4 emissColor = m_materials[matId].colors[EMISSION_COLOR];
    vec4 lightIntensity = emissColor * texColor;

    if(lightId != 0xFFFFFFFF)
    {
      const float lightCos = dot(rayDirAndFar.xyz, m_lights[lightId].norm.xyz);
      const float lightDirectionAtten = (lightCos < 0.0f || m_lights[lightId].geomType == LIGHT_GEOM_SPHERE) ? 1.0f : 0.0f;
      lightIntensity = LightIntensity(lightId, lambda, ray_pos, rayDirAndFar.xyz)*lightDirectionAtten;
    }

    float misWeight = 1.0f;
    if(ubo.m_intergatorType == INTEGRATOR_MIS_PT) 
    {
      if(bounce > 0 && lightId != 0xFFFFFFFF)
      {
        const float lgtPdf  = LightPdfSelectRev(int(lightId)) * LightEvalPDF(int(lightId), ray_pos, ray_dir, hit.pos, hit.norm, 1.0f);
        misWeight           = misWeightHeuristic(prevPdfW, lgtPdf);
        if (prevPdfW <= 0.0f) // specular bounce
          misWeight = 1.0f;
      }
    }
    else if(ubo.m_intergatorType == INTEGRATOR_SHADOW_PT && hasNonSpecular(currRayFlags))
      misWeight = 0.0f;
    
    const bool isDirectLight = !hasNonSpecular(currRayFlags);
    const bool isFirstNonSpec = (currRayFlags & RAY_FLAG_FIRST_NON_SPEC) != 0;
    if(ubo.m_renderLayer == FB_INDIRECT && (isDirectLight || isFirstNonSpec))
      misWeight = 0.0f;

    vec4 currAccumColor = accumColor;
    vec4 currAccumThroughput = accumThoroughput;
    
    currAccumColor += currAccumThroughput * lightIntensity * misWeight;
   
    accumColor = currAccumColor;
    rayFlags   = currRayFlags | (RAY_FLAG_IS_DEAD | RAY_FLAG_HIT_LIGHT);
    return;
  }
  
  const uint bounceTmp    = bounce;
  const BsdfSample matSam = MaterialSampleAndEval(matId, tid, bounceTmp, lambda, a_gen, (-1.0f)*ray_dir, hit.norm, hit.tang, hit.uv, misPrev, currRayFlags);
  const vec4 bxdfVal = matSam.val * (1.0f / max(matSam.pdf, 1e-20f));
  const float  cosTheta   = abs(dot(matSam.dir, hit.norm)); 

  MisData nextBounceData      = misPrev;        // remember current pdfW for next bounce
  nextBounceData.matSamplePdf = (matSam.flags & RAY_EVENT_S) != 0 ? -1.0f : matSam.pdf; 
  nextBounceData.cosTheta     = cosTheta;   
  misPrev                    = nextBounceData;

  if(ubo.m_intergatorType == INTEGRATOR_STUPID_PT)
  {
    accumThoroughput *= cosTheta * bxdfVal; 
  }
  else if(ubo.m_intergatorType == INTEGRATOR_SHADOW_PT || ubo.m_intergatorType == INTEGRATOR_MIS_PT)
  {
    const vec4 currThoroughput = accumThoroughput;
    const vec4 shadeColor = in_shadeColor;
    vec4 currAccumColor = accumColor;

    currAccumColor += currThoroughput * shadeColor;
    accumColor       = currAccumColor;
    accumThoroughput = currThoroughput*cosTheta*bxdfVal; 
  }

  // compute point on the other side of the surface in case of transmission
  if((matSam.flags & RAY_EVENT_T) != 0)
  {
    hit.pos = hit.pos + hitDist * ray_dir * 2 * 1e-6f;
  }  

  rayPosAndNear = vec4(OffsRayPos(hit.pos, hit.norm, matSam.dir), 0.0f); // todo: use flatNormal for offset
  rayDirAndFar  = vec4(matSam.dir, FLT_MAX);
  
  uint nextFlags = ((currRayFlags & ~RAY_FLAG_FIRST_NON_SPEC) | matSam.flags); // always force reset RAY_FLAG_FIRST_NON_SPEC;
  if(ubo.m_renderLayer == FB_DIRECT && hasNonSpecular(currRayFlags))   // NOTE: use currRayFlags for check, not nextFlags because of MIS: a ray may hit light source in next bounce
    nextFlags |= RAY_FLAG_IS_DEAD;                                 //       but if we already have non specular bounce previously, definitely can stop  
  else if(!hasNonSpecular(currRayFlags) && hasNonSpecular(nextFlags))
    nextFlags |= RAY_FLAG_FIRST_NON_SPEC;
  rayFlags      = nextFlags;                                   

}

void kernel_RayTrace2(uint tid, uint bounce, in vec4 rayPosAndNear, in vec4 rayDirAndFar, in float a_time, inout vec4 out_hit1, inout vec4 out_hit2, inout vec4 out_hit3, inout uint out_instId, inout uint rayFlags) 
{
  
  if(tid >= ubo.m_maxThreadId)
    return;
  uint currRayFlags = rayFlags;
  if(isDeadRay(currRayFlags))
    return;

  const vec4 rayPos = rayPosAndNear;
  const vec4 rayDir = rayDirAndFar ;
  const float  time   = a_time;

  const CRT_Hit hit   = m_pAccelStruct_RayQuery_NearestHitMotion(rayPos, rayDir, time);
  RecordRayHitIfNeeded(bounce, hit);

  if(hit.geomId != uint32_t(-1))
  {
    const vec2 uv = vec2(hit.coords[0],hit.coords[1]);
    
    // slightly undershoot the intersection to prevent self-intersection and other bugs
    const vec3 hitPos = rayPos.xyz + hit.t * (1.f - 1e-6f) * rayDir.xyz;
    // const float3 overHit  = to_float3(rayPos) + hit.t * (1.f + 1e-6f) * to_float3(rayDir);

    // alternative, you may consider Johannes Hanika solution from  Ray Tracing Gems2  
    /////////////////////////////////////////////////////////////////////////////////
    // // get distance vectors from triangle vertices
    // vec3 tmpu = P - A, tmpv = P - B, tmpw = P - C
    // // project these onto the tangent planes
    // // defined by the shading normals
    // float dotu = min (0.0, dot(tmpu , nA))
    // float dotv = min (0.0, dot(tmpv , nB))
    // float dotw = min (0.0, dot(tmpw , nC))
    // tmpu -= dotu*nA
    // tmpv -= dotv*nB
    // tmpw -= dotw*nC
    // // finally P' is the barycentric mean of these three
    // vec3 Pp = P + u*tmpu + v*tmpv + w*tmpw
    /////////////////////////////////////////////////////////////////////////////////

    const uint triOffset  = m_matIdOffsets[hit.geomId];
    const uint vertOffset = m_vertOffset  [hit.geomId];
  
    const uint A = m_triIndices[(triOffset + hit.primId)*3 + 0];
    const uint B = m_triIndices[(triOffset + hit.primId)*3 + 1];
    const uint C = m_triIndices[(triOffset + hit.primId)*3 + 2];

    const vec4 data1 = (1.0f - uv.x - uv.y)*m_vNorm4f[A + vertOffset] + uv.y*m_vNorm4f[B + vertOffset] + uv.x*m_vNorm4f[C + vertOffset];
    const vec4 data2 = (1.0f - uv.x - uv.y)*m_vTang4f[A + vertOffset] + uv.y*m_vTang4f[B + vertOffset] + uv.x*m_vTang4f[C + vertOffset];

    vec3 hitNorm = data1.xyz;
    vec3 hitTang = data2.xyz;
    vec2 hitTexCoord = vec2(data1.w,data2.w);

    // transform surface point with matrix and flip normal if needed
    //
    hitNorm = mul3x3(m_normMatrices[hit.instId], hitNorm);
    hitTang = mul3x3(m_normMatrices[hit.instId], hitTang);

    if(ubo.m_normMatrices2_size > 0)
    {
      vec3 hitNorm2 = mul3x3(m_normMatrices2[hit.instId], hitNorm);
      vec3 hitTang2 = mul3x3(m_normMatrices2[hit.instId], hitTang);

      hitNorm = mix(hitNorm, hitNorm2, time);
      hitTang = mix(hitTang, hitTang2, time);
    }

    hitNorm = normalize(hitNorm);
    hitTang = normalize(hitTang);
    
    const float flipNorm = dot(rayDir.xyz, hitNorm) > 0.001f ? -1.0f : 1.0f; // beware of transparent materials which use normal sign to identity "inside/outside" glass for example
    hitNorm              = flipNorm * hitNorm;
    hitTang              = flipNorm * hitTang; // do we need this ??

    if (flipNorm < 0.0f) currRayFlags |=  RAY_FLAG_HAS_INV_NORMAL;
    else                 currRayFlags &= ~RAY_FLAG_HAS_INV_NORMAL;
    
    const uint midOriginal = m_matIdByPrimId[m_matIdOffsets[hit.geomId] + hit.primId];
    const uint midRemaped  = RemapMaterialId(midOriginal, int(hit.instId));

    rayFlags              = packMatId(currRayFlags, midRemaped);
    out_hit1              = vec4(hitPos, hitTexCoord.x); 
    out_hit2              = vec4(hitNorm, hitTexCoord.y);
    out_hit3              = vec4(hitTang, hit.t);
    out_instId            = hit.instId;
  }
  else
  {
    const uint flagsToAdd = (bounce == 0) ? (RAY_FLAG_PRIME_RAY_MISS | RAY_FLAG_IS_DEAD | RAY_FLAG_OUT_OF_SCENE) : (RAY_FLAG_IS_DEAD | RAY_FLAG_OUT_OF_SCENE);
    rayFlags             = currRayFlags | flagsToAdd;
  }

}

void kernel_HitEnvironment(uint tid, in uint rayFlags, in vec4 rayDirAndFar, in MisData a_prevMisData, in vec4 accumThoroughput, inout vec4 accumColor) 
{
  
  if(tid >= ubo.m_maxThreadId)
    return;
  const uint currRayFlags = rayFlags;
  if(!isOutOfScene(currRayFlags))
    return;
  
  float envPdf = 1.0f;
  vec4 envColor = EnvironmentColor(rayDirAndFar.xyz, envPdf);

  const MisData misPrev = a_prevMisData;
  const bool isSpec = isSpecular(misPrev);
  const bool exitZero = (currRayFlags & RAY_FLAG_PRIME_RAY_MISS) != 0;

  if(ubo.m_intergatorType == INTEGRATOR_MIS_PT && ubo.m_envEnableSam != 0 && !isSpec && !exitZero)
  {
    float lgtPdf    = LightPdfSelectRev(int(ubo.m_envLightId))*envPdf;
    float bsdfPdf   = misPrev.matSamplePdf;
    float misWeight = misWeightHeuristic(bsdfPdf, lgtPdf); // (bsdfPdf*bsdfPdf) / (lgtPdf*lgtPdf + bsdfPdf*bsdfPdf);
    envColor *= misWeight;    
  }
  else if(ubo.m_intergatorType == INTEGRATOR_SHADOW_PT && ubo.m_envEnableSam != 0)
  {
    envColor = vec4(0.0f);
  }
  
  const uint camBackId = ubo.m_envCamBackId;
  if(exitZero && camBackId != uint(-1)) // apply camera back color to ray
  {
    const uint XY = m_packedXY[tid];
    const uint x  = (XY & 0x0000FFFF);
    const uint y  = (XY & 0xFFFF0000) >> 16;

    const vec2 texCoord = vec2((float(x) + 0.5f)/float(ubo.m_winWidth),(float(y) + 0.5f)/float(ubo.m_winHeight));

    envColor = texture(m_textures[camBackId], texCoord);
  }
 
  if(ubo.m_intergatorType == INTEGRATOR_STUPID_PT)     // todo: when explicit sampling will be added, disable contribution here for 'INTEGRATOR_SHADOW_PT'
    accumColor = (accumThoroughput) * envColor;
  else
    accumColor += (accumThoroughput) * envColor;

}

void kernel_InitEyeRay2(uint tid, inout vec4 rayPosAndNear, inout vec4 rayDirAndFar, inout vec4 wavelengths, inout vec4 accumColor, inout vec4 accumuThoroughput, inout RandomGen gen, inout uint rayFlags, inout MisData misData, inout float time) 
{
  

  if(tid >= ubo.m_maxThreadId)
    return;

  accumColor        = vec4(0, 0, 0, 0);
  accumuThoroughput = vec4(1, 1, 1, 1);
  RandomGen genLocal = m_randomGens[RandomGenId(tid)];
  rayFlags          = 0;
  misData           = makeInitialMisData();

  EyeRayData r = SampleCameraRay(genLocal, tid);
  
  if(KSPEC_SPECTRAL_RENDERING !=0 && ubo.m_spectral_mode != 0)
    wavelengths = SampleWavelengths(r.waveSam, LAMBDA_MIN, LAMBDA_MAX);
  else
    wavelengths = vec4(0.0f);

  time = r.timeSam;
 
  transform_ray3f(ubo.m_worldViewInv, r.rayPos, r.rayDir);

  rayPosAndNear = vec4(r.rayPos, 0.0f);
  rayDirAndFar  = vec4(r.rayDir, FLT_MAX);
  gen           = genLocal;

}

///////////////////////////////////////////////////////////////// subkernels here

void main()
{
  ///////////////////////////////////////////////////////////////// prolog
  const uint tid = uint(gl_GlobalInvocationID[0]); 
  ///////////////////////////////////////////////////////////////// prolog

  
  vec4 accumColor,  accumThroughput;
  vec4 rayPosAndNear,  rayDirAndFar;
  vec4 wavelengths;
  RandomGen gen; 
  MisData   mis;
  uint      rayFlags;
  float     time;
  kernel_InitEyeRay2(tid, rayPosAndNear, rayDirAndFar, wavelengths, accumColor, accumThroughput, gen, rayFlags, mis, time);

  for(uint depth = 0; depth < ubo.m_traceDepth; depth++) 
  {
    vec4 shadeColor,  hitPart1,  hitPart2,  hitPart3;
    uint instId;
    kernel_RayTrace2(tid, depth, rayPosAndNear, rayDirAndFar, time, 
                     hitPart1, hitPart2, hitPart3, instId, rayFlags);
    if(isDeadRay(rayFlags))
      break;
    
    kernel_SampleLightSource(tid, rayPosAndNear, rayDirAndFar, wavelengths, hitPart1, hitPart2, hitPart3, rayFlags, time,
                             depth, gen, shadeColor);

    kernel_NextBounce(tid, depth, hitPart1, hitPart2, hitPart3, instId, shadeColor,
                      rayPosAndNear, rayDirAndFar, wavelengths, accumColor, accumThroughput, gen, mis, rayFlags);

    if(isDeadRay(rayFlags))
      break;
  }

  kernel_HitEnvironment(tid, rayFlags, rayDirAndFar, mis, accumThroughput,
                        accumColor);

  kernel_ContributeToImage_m_packedXY_out_color(tid, rayFlags, kgenArgs.channels, accumColor, gen, 0, wavelengths, 0);

}

